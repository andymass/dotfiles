" ────────────────────────────────────────────────────────────────────────
"       ___              __     _                _
"      /   |  ____  ____/ /_  _( )_____   _   __(_)___ ___  __________
"     / /| | / __ \/ __  / / / /// ___/  | | / / / __ `__ \/ ___/ ___/
"    / ___ |/ / / / /_/ / /_/ / (__  )   | |/ / / / / / / / /  / /__
"   /_/  |_/_/ /_/\__,_/\__, / /____/    |___/_/_/ /_/ /_/_/   \___/
"                      /____/
" ────────────────────────────────────────────────────────────────────────

" overview {{{1
" \\, <f5>,     update and compile document (filetype dependent)
" \=, \-
" \g=, \g-      increment, decrement
" \.            locally change directory
" \/            remove highlight
" \[            CtrlP MRU
" \]{motion},
" \]],
" {Visual}\],   Sling to tmux
" \a
" \b
" \c
" \d            YcmCompleter GoTo (mnemonic: definition)
" \e
" \f            CtrlP to file under cursor
" \g            :Ag prompt
" \G            Ag search for word under cursor
" \h
" \i            YcmDiagnostic (TODO)
" \j
" \k
" \l            vimtex mappings
" \m            enable modeline & reload (TODO)
" \n
" \o            CtrlP (all files in directory)
" \p            CtrlP buffers
" \q            CtrlP quickfix
" \Q            Toggle quickfix
" \r
" \s            Syntax check
" \S            Syntax toggle
" \t            CtrlP tags
" \T            Toggle tagbar
" \u            Toggle latex-to-unicode
" \v            Toggle textwidth
" \w            CtrlP locations
" \W            Toggle location list
" \x            :VdebugEval prompt (TODO)
" \y            Yank to tmux
" \z            Re-sync syntax highlighting
"
" gy{motion},
" gyy,
" {Visual}gy    figlet  
" gY            figlet font picker
" g.            globally change directory
" gb, gB        show syntax under cursor
" gl            convert :emoji: into emoji
"
" yp, yP        open line and set paste (above, below)
"
" free keys: gz zp zy z/ g/ z\ g\
" <f20> to <f37>

" Todo
"   - ripgrep
"   - syntastic -> ale
"   - vdebug
"   - completion
"   - automatic indent / modelines
"   - supertab chain?
"   - what is setting up bracketed paste?
"   - window management
"   - map for :Trim
"   - vim-devicons
"   - fmt equalprg vs q
"   - help abbr
"   - look into cycle/switch
"   - clipbrd/tregisters

" }}}1

" the basics {{{1
" set nocompatible
set ts=4
set sw=4
set textwidth=74
set wm=2
set cc=+1
set expandtab
set bs=indent
set ffs=unix,dos

set noswapfile
set virtualedit=block

set ttimeout ttimeoutlen=10
set mouse=a ttymouse=xterm2

set nu
if !&hlsearch | set hlsearch | endif
set spell spelllang=en_us
set spellsuggest=best,5
set thesaurus=~/.vim/config/mthesaur.txt
" set dictionary=/usr/share/dict/words

" set formatprg=fmt\ --width=&textwidth
set formatprg=fmt\ --width=74

" j: remove comments when joining
" l: don't break long lines in insert mode
set formatoptions+=jl

" changes the behavior of <cr> in two ways:
"   - <cr> now accepts an autocomplete
"   - <cr> starts a new undo sequence
"   xxx conflicts with ycm
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" set fillchars=vert:║,fold:- ─
set fillchars=stl:\ ,stlnc:\ ,fold:\ ,vert:│
set listchars=trail:·
let &showbreak = " ❯❯❯ "   " ∴  ⮱  → ↳ 🡆 ❯

set laststatus=2
set scrolloff=2
set wildmenu
set wildmode=longest:full,full
set suffixes+=.pdf,.synctex
set isfname-==

set splitbelow   " nb ctrlp sets this
set splitright
set switchbuf=useopen " ,split
set previewheight=18

set nomodeline modelines=3
set infercase

set nosol

" under ssh, disable clipboard to make things faster
if $SSH_CLIENT != ''
    set clipboard=exclude:.*
endif

" use ag for grepping
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --smart-case\
        \ --column\ --follow\ -C0
    set grepformat=%f:%l:%c:%m
    command! -nargs=+ -complete=file -bar
        \ Ag silent! grep! <args>|cwindow|redraw!
endif

if exists(':Ag')
    function! s:Ag_cword()  " XXX this doesn't actually work..
        return escape(shellescape(expand("<cword>"),1),'\|#%')
    endfunction
    nnoremap <leader>G :Ag -Q <c-r>=<sid>Ag_cword()<cr><cr>
    nnoremap <leader>g :Ag 
endif

" global rc options
let g:rc_disable_youcompleteme = 0

" xxx move this
if get(g:, 'rc_disable_youcompleteme', 0)
    let g:loaded_youcompleteme = 1
endif

" load site-specific configs
let g:config_home = expand('~/.vim/config')
autocmd BufRead .vimrc exe 'setl path+='.g:config_home

let g:within_tmux = ($TMUX != '')

let g:site_config = g:config_home.'/site.'.hostname().'.vim'
if !filereadable(g:site_config)
    let g:site_config = g:config_home.'/site.default.vim'
endif

exec 'source' g:site_config

" }}}1

" ────────────────────────────────────────────────────────────────────────
"             __            _
"      ____  / /_  ______ _(_)___  _____
"     / __ \/ / / / / __ `/ / __ \/ ___/
"    / /_/ / / /_/ / /_/ / / / / (__  )
"   / .___/_/\__,_/\__, /_/_/ /_/____/
"  /_/            /____/
" ────────────────────────────────────────────────────────────────────────
" plugins {{{1

augroup rc_pre_filetype_plugin
    autocmd!
    autocmd FileType * call s:PreFTPlugin(expand("<amatch>"))
augroup END

" ~/.vim/config/plugs.vim
execute 'source' g:config_home.'/plugs.vim'

if !exists("g:colors_name")

endif

" colorscheme setup
" set background=dark
" if !$NO_COLORSCRIPT && &term !~ 'putty'
" "   setting shell path is not necessary
" "    let g:base16_shell_path='~/scripts/base16-shell/'
"     let base16colorspace=256
" endif
" colorscheme base16-eighties
" colorscheme nord
" let g:airline_theme = 'nord'

" jump to the last position in file when reopening
augroup vim_startup
    autocmd!
    autocmd BufReadPost * 
        \ if line("'\"") > 0 && line("'\"") <= line("$")
        \| exe "normal! g`\"zv" | endif
augroup END

" allows cursor to change
" XXX this can be cleaned up, maybe just use wincent/terminus
" also see jszakmeister/vim-togglecursor
if exists('$TMUX')
    " let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    " let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    " let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
    " this requires tmux codes to be set appropriately
    let &t_SI = "\<Esc>[6 q"
    let &t_EI = "\<Esc>[2 q"
    let &t_SR = "\<Esc>[4 q"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
endif


" ."\<Esc>]50;BlinkingCursorEnabled=2\x7",


" transparent background
if !has("gui_running")
    hi Normal ctermbg=none
end

" disable intro
set shortmess+=I

" }}}1

" ────────────────────────────────────────────────────────────────────────
"             __            _                      __  _
"      ____  / /_  ______ _(_)___     ____  ____  / /_(_)___  ____  _____
"     / __ \/ / / / / __ `/ / __ \   / __ \/ __ \/ __/ / __ \/ __ \/ ___/
"    / /_/ / / /_/ / /_/ / / / / /  / /_/ / /_/ / /_/ / /_/ / / / (__  )
"   / .___/_/\__,_/\__, /_/_/ /_/   \____/ .___/\__/_/\____/_/ /_/____/
"  /_/            /____/                /_/
" ────────────────────────────────────────────────────────────────────────
" plugin options {{{1

" clipbrd {{{2
"
let g:no_clipbrd_maps = 1

" }}}2

" unicode {{{2

" (this is a typo in the plugin)
nmap <sid>(unicode_un0) <plug>(UnicodeSwapCompleteName))
nmap <sid>(unicode_un) <plug>(UnicodeSwapCompleteName)

" }}}2

" unicoder {{{2

let g:unicoder_cancel_normal = 1
let g:unicoder_cancel_insert = 1
let g:unicoder_cancel_visual = 1
let g:unicoder_no_map = 1

" XXX todo
" nnoremap <C-l> :call unicoder#start(0)<CR>
" inoremap <C-l> <Esc>:call unicoder#start(1)<CR>
" vnoremap <C-l> :<C-u>call unicoder#selection()<CR>

" }}}2

" ultisnips {{{2
let g:UltiSnipsSnippetDirectories=["ultisnips"]
let g:UltiSnipsExpandTrigger='<c-z>'  " '<sid>(snipexpand)'
let g:UltiSnipsListSnippets='<sid>(sniplist)'
let g:UltiSnipsJumpForwardTrigger='<c-f>'
let g:UltiSnipsJumpBackwardTrigger='<c-b>'
" let g:UltiSnipsJumpForwardTrigger='<c-j>'  
" let g:UltiSnipsJumpBackwardTrigger='<c-k>'



" TODO XXX
function! UltiSnipsShim()
   call UltiSnips#ExpandSnippetOrJump()
   if get(g:,'ulti_expand_or_jump_res',0)
      return ''
   else
      return 'hello'
   endif
endfunction
" inoremap <c-]> <c-r>=UltiSnipsShim()<cr>

" let g:UltiSnipsListSnippets

" let g:vimtex_imaps_snippet_engine = 'ultisnips'
    " \ 'leader' : 0, 
 
" }}}2

" vimtex {{{2

" autocmd FileType tex :iabbr <buffer> ... \dots

let g:vimtex_view_forward_search_on_start = 0
let g:vimtex_imaps_leader = '`'
autocmd FileType tex imap <silent><buffer> `` ``
let g:vimtex_indent_ignored_envs = ['document', 'aligned']

" cleanup vimtex viewer windows
" function VimtexCleanViewers()
"     if !executable('xdotool') | return | endif

"     let l:xwin_id = b:vimtex.viewer.xwin_id
"     if !l:xwin_id | return | endif

"     call system('xdotool windowclose '. l:xwin_id)
" endfunction

function! VimtexCleanViewers()
    if !executable('xdotool') | return | endif

    for l:b in range(1, bufnr('$'))
        let l:vimtex = getbufvar(l:b, 'vimtex')
        if empty(l:vimtex) | continue | endif

        let l:xwin_id = l:vimtex.viewer.xwin_id
        if !l:xwin_id | continue | endif

        call system('xdotool windowclose '. l:xwin_id)
    endfor
endfunction

augroup vimtex_cleanup
    au!
    au VimLeavePre * call VimtexCleanViewers()
    " au User VimtexEventQuit call VimtexCleanViewers()
    au User VimtexEventQuit echo 'vimtex quitting '.bufname('%').'|'.b:vimtex_id | sleep 400m
augroup END

" }}}2



" call vimtex#imaps#add_map({
"     \ 'lhs' : 'test',
"     \ 'rhs' : '\tested',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})
"

" control space
" let g:vimtex_imaps_leader = "<c-@>

" call vimtex#imaps#add_map({
"     \ 'lhs' : '{',
"     \ 'rhs' : '{}',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})

" function! vimtex#imaps#wrap_math(lhs, rhs) " 
"       return s:is_math() ? a:rhs : a:lhs
"   endfunction

"" %! TeX program=XeLaTeX
" function! DetectTexProgram()

"   let l:pat = '^\c\s*%\s*!\?\s*tex\s\+\(TS-\)\?program\s*=\s*\zs.*\ze\s*$'
"   let l:engine_list = {
"       \ 'pdflatex'         : '',
"       \ 'lualatex'         : '-lualatex',
"       \ 'xelatex'          : '-xelatex',
"       \ 'context (luatex)' : '-pdflatex=context',
"       \ 'context (pdftex)' : '-pdflatex=''texexec --xtx''',
"       \ 'context (xetex)'  : '-pdflatex=texexec',
"       \  }

"       " \ 'pdftex'           : 'pdftex',
"       " \ 'luatex'           : 'luatex',
"       " \ 'xetex'            : 'xetex',

"   for l:line in getline(1, 5)
"     let l:engine = matchstr(l:line, l:pat)
"     if len(l:engine) > 0
"       if has_key(l:engine_list, tolower(l:engine)) > 0
"         let l:opt = ' '.l:engine_list[tolower(l:engine)].' '
"         let g:vimtex_latexmk_options .= l:opt
"       else
"         echoerr 'Unknown engine '.l:engine
"       endif
"     endif
"   endfor

" endfunction

" autocmd FileType tex call DetectTexProgram()


" if has("autocmd") && exists("+omnifunc")
"     autocmd Filetype *
"         \   if &omnifunc == "" |
"         \       setlocal omnifunc=syntaxcomplete#Complete |
"         \   endif
" endif


" xxx where should this be?
let g:user_completion_chain = [ 
     \ 'emoji#complete', 
     \ 'syntaxcomplete#Complete',
     \ ]

" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=MyComplete |
"     \   endif

function! EmojiComplete(findstart, base)
    let l:omni = emoji#complete(a:findstart, a:base)
    return l:omni

    " if a:findstart
    "     if l:omni < 0
    "         return -1
    "     endif
    "     return l:omni+1
    " endif
    " return l:omni

    " echo 'findstart' a:findstart 'base' a:base '-> omni' l:omni
    " sleep 1
    " echo emoji#complete(a:findstart, a:base)
    " sleep 2
endfunction

" let g:ycm_seed_identifiers_with_syntax = 1
" let g:ycm_collect_identifiers_from_tags_files = 1


" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=EmoComplete |
"     \   endif

" SuperTab?
" if &omnifunc == ""
    " setlocal omnifunc=MyComplete
    " setlocal omnifunc=emoji#complete
" endif

" if the filetype provides no omnifunc, use the custom chain
autocmd Filetype * if &omnifunc == "" 
    \ |     setlocal omnifunc=CompletionChain
    \ | endif

" autocmd Filetype * if &omnifunc == "" 
"     \ |     setlocal omnifunc=syntaxcomplete#Complete
"     \ | endif


call SiteSetupAppearance()

" for f in glob(g:config_home.'/site.'.hostname().'.vim', 1, 1)
"     exec 'source' f
" endfor

" airline {{{2
let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : 'N',
      \ 'i'  : 'I',
      \ 'R'  : 'REPLACE',
      \ 'v'  : 'V',
      \ 'V'  : 'V-LINE',
      \ 'c'  : ':',
      \ '' : 'V-BLOCK',
      \ }

let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_alt_sep = ''

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = '🔒'   " 
let g:airline_symbols.linenr = '≡' " ♫'
let g:airline_symbols.paste = '🐧'   	" hhp
let g:airline_symbols.spell = 'S'   " 📝'
let g:airline_symbols.whitespace = 'w'

let g:airline_symbols.notexists = '*'
let g:airline_symbols.maxlinenr = ''

" let g:airline_symbols.modified = 'm'
" let g:airline_symbols.modified = ' 💡'
" let g:airline_symbols.space = '~'
" let g:airline_symbols.crypt = "\xf0\x9f\x94\x92"



let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#bufferline#enabled = 0
let g:airline#extensions#syntastic#enabled = 1
let g:airline#extensions#tagbar#enabled = 1
let g:airline#parts#ffenc#skip_expected_string='utf-8[unix]'

" xxx
" let g:airline#extensions#tagbar#flags = 'p'

let g:airline#extensions#vimtex#enabled = 0
let g:airline#extensions#vimtex#left = "("
let g:airline#extensions#vimtex#right = ")"


let g:airline_section_error = ''  " temporary, to hide red arrow
let g:airline_section_warning = ''
let g:airline_detect_spelllang = 0

" let g:airline_skip_empty_sections = 1

" let spc = g:airline_symbols.space
" let g:airline_section_z = airline#section#create(['windowswap', 'obsession', '%3p%%'.spc, 'linenr', 'maxlinenr', spc.':%3v'])

" let g:airline_section_y = 
"             \ '%{airline#util#prepend(airline#parts#ffenc(),0)}'
"             \ . '%{airline#util#wrap("✦".winnr().".".bufnr("%"),10)}'
"

function! WindowNumber(...)
    let builder = a:1
    let context = a:2
    echo builder | sleep 1
    call builder.add_section('airline_b', '%{tabpagewinnr(tabpagenr())}')
    return 0
endfunction
" call airline#add_statusline_func('WindowNumber')
" call airline#add_inactive_statusline_func('WindowNumber')

function! ThisWay()
    return '✦'.winnr().'.'.bufnr("%").' '
endfunction
call airline#parts#define_function('thisway', 'ThisWay')

function! GetFooText()
    return 'hello'
endfunction
call airline#parts#define_function('foo', 'GetFooText')
" call airline#parts#define_minwidth('ffenc', 100)
call airline#parts#define_minwidth('foo', 50)
" let g:airline_section_y = airline#section#create_right(['ffenc', 'foo'])

" let g:airline_section_z = airline#section#create(['windowswap', '%3p%% ', 'linenr', 'maxlinenr', ' :%3v'])


" XXX
let g:airline#extensions#windowswap#enabled = 1
let g:airline#extensions#windowswap#indicator_text = '👌' " 🍔 WS'

let g:airline_section_z = airline#section#create(
    \ ['windowswap', 'thisway', 'linenr', 'maxlinenr', ' :%3v'])

let g:airline#extensions#default#section_truncate_width = {
   \ 'b': 75, 'x': 110, 'y': 88, 'z': 50, 
   \ 'warning': 80, 'error': 80, }

if 0


function! _ShortenDir()
    return substitute(fnamemodify(getcwd(),':~:.'),'\~/Dropbox','DB','')
endfunction

let g:airline_section_b = "%<%{_ShortenDir()}/"
let g:airline_section_x = '%{airline#extensions#tagbar#currenttag()}' 
let g:airline_section_y = '%{airline#parts#filetype()}'
let g:airline_section_z = '%p%% %#__accent_bold#%l%#__restore__#:%2v'
" let g:airline_section_warning = ''
" let g:airline_section_gutter = ''

" let g:airline#extensions#default#section_truncate_width = {
"   \ 'b': 79, 'x': 60, 'y': 60, 'z': 45 }

" there is a base16_eighties theme but it maps normal mode to green
" see https://github.com/vim-airline/vim-airline/issues/1067
"" let g:airline_theme = 'base16'

endif


" }}}2

" gutentags {{{2
let g:gutentags_project_root = [ 'latexmkrc' ]
let g:gutentags_generate_on_missing = 0
let g:gutentags_generate_on_new = 0
let g:gutentags_generate_on_write = 1
let g:gutentags_cache_dir = '/home/andy/.cache/gutentags'

" let g:gutentags_ctags_tagfile
" let g:gutentags_project_root = ['tags'] 
" let g:gutentags_add_default_project_roots = 0
"}}}2

" netrw/vim-vinegar {{{2
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_altv = 1
"}}}2

" viewdoc {{{2
" XXX
let g:viewdoc_open = 'topleft new'
" let g:ViewDoc_tex = 'ViewDoc_help_custom' 
" let g:viewdoc_only = 1

" default to ViewDocHelp!
let g:no_viewdoc_abbrev = 1
let g:no_viewdoc_maps = 1

" cnoreabbrev <expr> h      getcmdtype()==':'
"     \ && getcmdline()=='h'     ? 'ViewDocHelp!' : 'h'
" cnoreabbrev <expr> help   getcmdtype()==':'
"     \ && getcmdline()=='help'  ? 'ViewDocHelp!' : 'help'

" function! s:Help(args)
"         \ :<C-U>exe 'topleft help '.scriptease#helptopic()<CR>
" endfunction
" command! -nargs=* -complete=help Help call <SID>smart_help(<q-args>)
" todo :let @/ =


" XXX leftabove instead
cnoreabbrev <expr> h      getcmdtype()==':'
    \ && getcmdline()=='h'     ? 'topleft help' : 'h'
cnoreabbrev <expr> help   getcmdtype()==':'
    \ && getcmdline()=='help'  ? 'topleft help' : 'help'

"}}}2

" quickscope {{{2
let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

let g:qs_second_occurrence_highlight_color_gui = '#f4e541'
let g:qs_first_occurrence_highlight_color_gui = '#41f468'

"}}}2


let g:Tex_Leader2='<C-\>'

let g:tex_flavor='latex'
let g:Tex_AutoFolding=0
let g:Tex_ShowErrorContext=0
let g:tex_comment_nospell=1
let g:Imap_FreezeImap=1
let g:Tex_EnvironmentMaps=0
let g:Tex_EnvironmentMenus=0

let g:Tex_DefaultTargetFormat='pdf'
let g:Tex_MultipleCompileFormats='pdf'
" let g:Tex_ViewRule_pdf='zathura -x "gvim+%{line} %{input}"'
" TODO: right now we save this only for tex files
function! SynctexInverseSearch(line, file)
    echo a:file
    " let bufnr = bufnr('^'.a:file.'$')
    " exe bufwinnr.'winc w'
endfunction
autocmd FileType tex let $VIM_SERVERNAME=v:servername

let g:Tex_ViewRuleComplete_pdf='zathura -x '
    \ . '"vim --servername {v:servername} --remote +\%{line} \%{input}" '
    \ . '$*.pdf 2>/dev/null &'
let g:Tex_ViewRule_pdf='synctex_wrapper'

let g:Tex_CompileRule_pdf='pdflatex -synctex=-1 -interaction=nonstopmode -file-line-error-style $* -max-print-line=255 -shell-escape'
function! SetXeTex()
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
endfunction

function! CompileXeTex()
    let oldCompileRule=g:Tex_CompileRule_pdf
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
    call Tex_RunLaTeX()
    let g:Tex_CompileRule_pdf=oldCompileRule
endfunction

autocmd BufNewFile,BufRead *.tex 
    \ if getline(1) =~? 'xetex\|xelatex' | call SetXeTex() | endif

function! OpenLog()
	let mainfname = Tex_GetMainFileName()
	let mfnlog = fnamemodify(mainfname, ":t:r").'.log'
    execute 'split '.mfnlog
endfunction

" vdebug
let g:vdebug_keymap = {
    \    "run" : "<F13>", 
    \    "run_to_cursor" : "<Leader>R",
    \    "step_over" : "<F2>",
    \    "step_into" : "<F3>",
    \    "step_out" : "<F4>",
    \    "close" : "<Leader>c",
    \    "detach" : "<F7>",
    \    "set_breakpoint" : "<F10>",
    \    "get_context" : "<Leader>w",
    \    "eval_under_cursor" : "<Leader>v",
    \    "eval_visual" : "<Leader>e",
    \}


" vimtex
let g:vimtex_delim_list = {'mods' : {}, 'delim_tex': {}}
let g:vimtex_delim_list.mods.name = [
      \ ['\left', '\right'],
      \ ['\mleft', '\mright'],
      \ ['\bigl', '\bigr'],
      \ ['\Bigl', '\Bigr'],
      \ ['\biggl', '\biggr'],
      \ ['\Biggl', '\Biggr'],
      \]
let g:vimtex_delim_toggle_mod_list = [
      \ ['\bigl', '\bigr'],
      \ ['\Bigl', '\Bigr'],
      \ ['\biggl', '\biggr'],
      \ ['\Biggl', '\Biggr'],
      \]

let g:vimtex_delim_list.delim_tex.name = [
      \ ['[', ']'],
      \ ['{', '}'],
      \ ['``', "''"],
      \ ['`', "'"],
      \]

let g:vimtex_compiler_latexmk = {
    \   'backend'    : 'jobs',
    \   'background' : 1,
    \   'continuous' : 0, 
    \   'callback'   : 0
    \}

" xxx make tex <buffer> only!
" nnoremap <silent> <plug>(vimtex-delim-toggle-modifier-reverse)
"     \ :call vimtex#delim#toggle_modifier(-1)<cr>

nmap <silent> <leader>l.  :<c-u>lcd <c-r>=b:vimtex.root<cr><cr>:pwd<cr>
nmap <silent> <leader>lg.  :<c-u>cd <c-r>=b:vimtex.root<cr><cr>:pwd<cr>

nmap <silent> cd <plug>(vimtex-delim-toggle-modifier)
nmap <silent> cD <plug>(vimtex-delim-toggle-modifier-reverse)
xmap <silent> cd <plug>(vimtex-delim-toggle-modifier)
xmap <silent> cD <plug>(vimtex-delim-toggle-modifier-reverse)
nmap <silent> cse* <plug>(vimtex-env-toggle-star)
nmap <silent> csc* <plug>(vimtex-cmd-toggle-star)
" alternative maps cd, cD, co, cO, csd+/-

let g:vimtex_view_automatic = 0
let g:vimtex_view_method = 'zathura'
let g:vimtex_quickfix_open_on_warning = 0

let g:vimtex_quickfix_latexlog = {
    \ 'overfull' : 0,
    \ 'underfull' : 0,
    \}

let g:vimtex_format_enabled = 1


" let g:vimtex_latexmk_continuous = 0
" let g:vimtex_latexmk_background = 1
" let g:vimtex_quickfix_ignore_all_warnings = 0
" let g:vimtex_latexmk_build_dir='build'
" function! SetBuildDir()
 "    let g:vimtex_latexmk_build_dir='build'
" endfunction
" augroup vimtex_config
 "    au!
 "    au User VimtexEventInitPost call SetBuildDir()
" augroup END

" zotero + betterbibtex
augroup filetype_tex_b
    autocmd!
    autocmd FileType tex nnoremap <buffer> <silent> <leader>c :r!cite<cr>
    autocmd Filetype tex nmap <buffer> <silent> K <plug>(vimtex-doc-package)
augroup END

" vimtex + surround
augroup latex_surround
   autocmd!
   autocmd FileType tex call s:latexSurround()
augroup END

function! s:latexSurround()
   let b:surround_{char2nr("e")}
     \ = "\\begin{\1environment: \1}\n\t\r\n\\end{\1\1}"
   let b:surround_{char2nr("c")} = "\\\1command: \1{\r}"
endfunction

" vimtex + ycm
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
    \ 're!\\[A-Za-z]*cite[A-Za-z]*(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\[A-Za-z]*ref({[^}]*|range{([^,{}]*(}{)?))',
    \ 're!\\hyperref\[[^]]*',
    \ 're!\\includegraphics\*?(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\(include(only)?|input){[^}]*',
    \ 're!\\\a*(gls|Gls|GLS)(pl)?\a*(\s*\[[^]]*\]){0,2}\s*\{[^}]*',
    \ 're!\\includepdf(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\includestandalone(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\usepackage(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\documentclass(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\[A-Za-z]*',
    \ ]

" let g:ycm_min_num_of_chars_for_completion = 99
" let g:ycm_cache_omnifunc = 0

let g:ycm_semantic_triggers.text = [
    \ 're!:[A-Za-z]*',
    \ ]

let g:ycm_key_invoke_completion = '<f19>'
" let g:ycm_cache_omnifunc = 0

let g:ycm_key_detailed_diagnostics = '<f2>'

function! VimtexHelpLookup()
    let l:start = vimtex#complete#omnifunc(1, [])
    let l:cword = expand('<cword>')
    let l:cword = substitute(l:cword, '^\\', '', '')
    let l:candidates = vimtex#complete#omnifunc(0, l:cword.'\>')
    if empty(l:candidates)
        echom 'nothing'
    else
        let l:pkgname = matchlist(l:candidates[0].menu, 
            \ '\v\[cmd:\s+(.+)\]')[1]
        echom l:pkgname
    end
endfunction

  let g:ycm_show_diagnostics_ui = 0

" nnoremap K :call VimtexHelpLookup()<cr>


" xxx this is bad, fix
" let g:ycm_semantic_triggers.text = [ 
"     \ 're!:arrow',
"     \ ]

" CompleteDone
" set completefunc=emoji#complete

" youcompleteme {{{2

let g:ycm_global_ycm_extra_conf = '~/.vim/.ycm_extra_conf.py'

let g:ycm_autoclose_preview_window_after_completion = 1

let g:ycm_filetype_blacklist = {
    \ 'tagbar'   : 1,
    \ 'qf'       : 1,
    \ 'notes'    : 1,
    \ 'markdown' : 1,
    \ 'unite'    : 1,
    \ 'vimwiki'  : 1,
    \ 'pandoc'   : 1,
    \ 'infolog'  : 1,
    \ 'mail'     : 1,
    \ 'netrw'    : 1,
    \ 'css'      : 1,
    \ }

" }}}2

" CtrlP {{{2
let g:ctrlp_extensions = [ 'tag', 'quickfix' ]
    " 'tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
    " \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']

if executable('ag')
    let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
          \ --ignore .git
          \ --ignore .svn
          \ --ignore .hg
          \ --ignore .DS_Store
          \ --ignore "**/*.pyc"
          \ --ignore $HOME/.cache
          \ -g ""'
endif

let g:ctrlp_clear_cache_on_exit = 1

let g:ctrlp_map = ''
let g:ctrlp_cmd = 'CtrlPMRUFiles'
let g:ctrlp_prompt_mappings = {
    \ 'PrtClearCache()':      ['<c-g>'],
    \ 'ToggleByFname()':      ['<c-d>'],
    \ 'PrtExit()':            ['<esc>', '<c-c>'],
    \ }

let g:ctrlp_working_path_mode = 'ca'


" call CtrlPGeneric(a_vim_list, 'MyGreatCallback')

" function! MyGreatCallback(selected_value) range
"     echo "You selected: " . a:selected_value
"  endfunction

" }}}2

" markdown (@gabrielelana, @ibabushkin)
let g:markdown_enable_mappings = 0

" Figlet
let g:figletFontDir='/usr/share/figlet/fonts'
let g:figletFont='slant'


" tagbar
" let g:tagbar_type_help = {
"     \ 'ctagstype' : 'help',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
"     \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'
" \ }

" http://stackoverflow.com/questions/26145505/using-vims-tagbar-plugin-for-latex-files
" \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'

" recent ctags development versions support latex under tex
" TODO: why are subsections not working?
" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'tex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'u:subsections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
" \ }

" Syntastic

" let g:syntastic_enable_perl_checker = 1
" function! EnablePerlCheck()
" endfunction
" autocmd FileType perl noremap <buffer> <Leader>s :<C-U>call EnablePerlCheck()<CR> 

" echo g:loaded_syntastic_plugin
" echo g:loaded_syntastic_util_autoload
" echo &runtimepath

" syntastic {{{2

" chktex is a bit too noisy
let g:syntastic_tex_checkers = ['lacheck']  " , 'chktex']
let g:syntastic_vim_checkers = ['vint']

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 4

let g:syntastic_mode_map = {
    \ "mode" : "passive",
    \ }

" XXX get mlint working
"    \ "passive_filetypes" : [ "matlab" ] }

" }}}2

" latex-to-unicode provided by the julia plugin
" let g:latex_to_unicode_file_types = ".*" = ["tex"]
let g:latex_to_unicode_auto = 1
let g:latex_to_unicode_eager = 1

" tpope's commentary
let g:commentary_map_backslash = 0

" makeshift
" consider writing my own, makeshift uses set makeprg not :compiler
" let g:makeshift_systems = {
"     \   'latexmkrc': 'latexmk',
"     \}

" XXX annoying mapping
" map <unique> <Leader>hlt <Plug>HiLinkTrace

let g:secure_modelines_allowed_items = [
    \ "textwidth",   "tw",
    \ "softtabstop", "sts",
    \ "tabstop",     "ts",
    \ "shiftwidth",  "sw",
    \ ]

function! FixSwTs()
    " echo 'FixSwTs' &shiftwidth
    " if &shiftwidth > 0
    "     let &tabstop = &shiftwidth
    "     let &shiftwidth=0
    " endif
    " XXX
    echo 'fixswts'
    let &tabstop = &shiftwidth
endfunction


" shiftwidth tabstop softtabstop smarttab expandtab
" preserveindent?

" au BufRead * echo 'BufRead '.&shiftwidth | sleep 1
" au BufEnter * call FixSwTs()

" au BufRead * call FixSwTs()
" au BufEnter * call FixSwTs()

" need to use BufEnter or BufReadEnter for overrides

" narrow region {{{2

let g:nrrw_rgn_nomap_nr = 1
let g:nrrw_rgn_nomap_Nr = 1

" }}} 2

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                               __     __  _           
"   _________  ____ ___  ____  / /__  / /_(_)___  ____ 
"  / ___/ __ \/ __ `__ \/ __ \/ / _ \/ __/ / __ \/ __ \
" / /__/ /_/ / / / / / / /_/ / /  __/ /_/ / /_/ / / / /
" \___/\____/_/ /_/ /_/ .___/_/\___/\__/_/\____/_/ /_/ 
"                    /_/                               
" ────────────────────────────────────────────────────────────────────────
" completion {{{1

" I use youcompleteme, so only the omnifunc is relevant


inoremap <silent> <expr> <c-u> pumvisible() ? "\<pageup>"   : "\<c-u>"
inoremap <silent> <expr> <c-d> pumvisible() ? "\<pagedown>" : "\<c-d>"


" explicit completion is performed with ctrl-L


" TODO expansion patterns

" insert-mode expansion is performed with ctrl-]
" mnemonic: ending ]
let g:user_expansion_chain = [
         \ 's:ExpandSnippet', 
         \ 's:ExpandEmoji', 
         \ 's:ExpandFallback',
         \ ]

function! s:ExpandSnippet()
   call UltiSnips#ExpandSnippetOrJump()
   if get(g:,'ulti_expand_or_jump_res',0)
      return 1
   else
      return 0
   endif
endfunction

function! s:ExpandEmoji()
   return EmojiReplace()
endfunction

function! s:ExpandFallback()
   call feedkeys("\<F19>")
   return 1
endfunction

function! s:DoExpansion()
   for l:fcn in g:user_expansion_chain
      let l:ret = call(l:fcn, [])
      if l:ret isnot 0
         let s:current_expansion = fcn
         return ''
      endif
   endfor
   return ''
endfunction

" normal available: Ctrl-@ Ctrl-X Ctrl-K Ctrl-\ Ctrl-_ 
" insert available: Ctrl-F Ctrl-L Ctrl-]...

" <c-r> instead of <expr> because we may modify the buffer
imap <sid>(expansion) <c-r>=<sid>DoExpansion()<cr>

" <c-r>=UltiSnipsShim()<cr>
imap <c-]> <sid>(expansion)

" function! FFF()
"    return mode()
" endfunction
" imap <F7> <c-r>=FFF()<cr>

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                                                      __
"      _________  ____ ___  ____ ___  ____ _____  ____/ /____
"     / ___/ __ \/ __ `__ \/ __ `__ \/ __ `/ __ \/ __  / ___/
"    / /__/ /_/ / / / / / / / / / / / /_/ / / / / /_/ (__  )
"    \___/\____/_/ /_/ /_/_/ /_/ /_/\__,_/_/ /_/\__,_/____/
"
" ────────────────────────────────────────────────────────────────────────
" commands {{{1

" source our .vimrc
command! ReloadVimrc source $MYVIMRC | redraw | echo $MYVIMRC.' reloaded'


" check for a shebang line and set up to execute
function! SetShebangRun()
    if executable(expand('%:p')) && getline(1) =~# '^#!'
        nnoremap <silent><buffer> <leader><bslash>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
        nnoremap <silent><buffer> <F5>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
    endif
endfunction

" displays a list of figlet fonts
function! s:FigPickerMode() range
    " echo 'range = ' . a:firstline . ',' . a:lastline
    " let l:orig_text = @"

    let figfontwinnr = bufwinnr('__Figpicker__')
    if figfontwinnr != -1
        execute figfontwinnr . 'wincmd w'
        silent execute ':0/' . g:figletFont
        return
    end
    execute 'silent keepalt vertical 20 new __Figpicker__'
    let g:figletPickerWindow = winnr()
    setl nonu cursorline nospell 
    setl noreadonly
    setl buftype=nofile bufhidden=hide noswapfile nobuflisted 
    setl nolist nowrap winfixwidth textwidth=0 
    execute ':.!figlist -d ' . g:figletFontDir . '| tail -n +3'
    :g/in this direc/d
    silent execute ':/' . g:figletFont
    try
        nnoremap <silent> <buffer> <esc> :<c-u>bd<cr>
        nnoremap <silent> <buffer> q :<c-u>bd<cr>
        nnoremap <silent> <buffer> 
            \ <cr> ^y$:let g:figletFont='<c-r>"'<cr><c-w>p
        " nnoremap <buffer>
        "     \ <space> :let g:figletFont='<c-r>=getline('.')<cr>'<cr><c-w>p:Figlet
        nnoremap <buffer> <space>
            \ :let g:figletFont='<c-r>=getline('.')<cr>'<cr>
    endtry
    setl nomodifiable nomodified
endfunction

command! -range -nargs=0 FigPick <line1>,<line2>call <sid>FigPickerMode()

" toggle syntastic passive mode
function! SyntaxToggle()
    execute 'SyntasticToggleMode'
    if g:syntastic_mode_map['mode'] ==? 'active'
        execute 'SyntasticCheck'
    endif
endfunction

" remove trailing whitespace
command! -range=% Trim <line1>,<line2>s/\s\+$//e
command! ShowTrailingWhitespace /\s\+$/

" put command output into a scratch buffer
" from http://vim.wikia.com/wiki/List_loaded_scripts
function! s:ScratchCmd(command, ...)
   redir => lines
   let saveMore = &more
   set nomore
   execute a:command
   redir END
   let &more = saveMore
   call feedkeys("\<cr>")
   new | setlocal buftype=nofile bufhidden=hide noswapfile
   put=lines
   if a:0 > 0
      execute 'vglobal/'.a:1.'/delete'
   endif
   if a:command == 'scriptnames'
      %substitute#^[[:space:]]*[[:digit:]]\+:[[:space:]]*##e
   endif
   silent %substitute/\%^\_s*\n\|\_s*\%$
   let height = min([line('$') + 3, 10])
   execute 'normal! z'.height."\<cr>"
   0
endfunction

command! -nargs=? ScriptnamesBuffer silent call <sid>ScratchCmd('scriptnames', <f-args>)
command! -nargs=+ ScratchCommand silent call <sid>ScratchCmd(<q-args>)

" function! vimtex#util#command(cmd)
"   let l:a = @a
"   try
"     silent! redir @a
"     silent! execute a:cmd
"     redir END
"   finally
"     let l:res = @a
"     let @a = l:a
"     return split(l:res, "\n")
"   endtry
" endfunction

" helper for control P to open file in preview window
function! PreviewFile(action, line)
    if a:action =~ '^e$'  
        let filename = fnameescape(fnamemodify(a:line, ':p'))
        call ctrlp#exit()
        exec 'pedit' . filename
        wincmd P 
    else
        " Use CtrlP's default file opening function
        call call('ctrlp#acceptfile', [a:action, a:line])
    endif
endfunction

" open to file under cursor with CtrlP
function! CtrlPCursorFile()
    let fname = expand("<cfile>")
    if empty(fname)
        echohl ErrorMsg
        echo "No file name under cursor"
        return
    endif

    let l:olddefault = 0
    if exists("g:ctrlp_default_input")
        let l:olddefault = g:ctrlp_default_input
    endif
    let g:ctrlp_default_input = fname

    let l:oldopenfunc = {}
    if exists("g:ctrlp_open_func")
        let l:oldopenfunc = g:ctrlp_open_func
    endif
    let g:ctrlp_open_func = { 'files' : 'PreviewFile' }

    " maybe use mixed mode instead: 0 -> ctrlp#mixed#id()?
    call ctrlp#init(0, { 'mode': 'r' })

    let g:ctrlp_default_input = l:olddefault
    let g:ctrlp_open_func = l:oldopenfunc
endfunction

" sling to tmux operator
let g:slimux_tmux_path = '/usr/bin/tmux'
function! SlingOper(type)
    if !exists("b:code_packet")
        let b:code_packet = { "target_pane": "", "type": "code" }
    endif
    let rv = getreg('"')
    let rt = getregtype('"')
    sil exe "'[,']yank"
    call SlimuxSendCode(@")
    call setreg('"',rv, rt)
endfunction

" returns a list of buffers
function! GetBufferList()
    redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction

" toggle either the quickfix or location windows 
function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 
            \ 'v:val =~ "'.a:bufname.'"'), 
            \ 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx.'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open 8')
    if winnr() != winnr
        " wincmd p
    endif
endfunction



command! Bind windo setl scrollbind | setl cursorbind | setl cursorline

" folding
set foldmethod=marker
" set foldlevel=0
set foldcolumn=0
set foldtext=FoldText()

function! FoldText()
    let l:fs = nextnonblank(v:foldstart)
    if l:fs > v:foldend
        let l:line = getline(v:foldstart)
    else
        let l:line = substitute(getline(l:fs), '\t',
            \ repeat(' ', &tabstop), 'g')
    endif
    let l:cms = split(substitute(&commentstring, ' ', '', 'g' ), '%s')
    let l:line = substitute(l:line, ''.l:cms[0] . '\s*', '', '')
    let l:line = substitute(l:line, '{\{3}\d\?\s*', '', '')
    let l:line = substitute(l:line, '\s\+$', '', '')

    let l:foldSize = 1 + v:foldend - v:foldstart
    let l:foldSizeStr = l:foldSize . ' lines'
    let l:foldLevelStr = repeat('•', v:foldlevel)
    let l:lineCount = line('$')
    let l:foldPerc = printf('(%.1f%%)', (100.0*l:foldSize)/l:lineCount)
    let l:left = '[ ' . l:line . ' '
    let l:right = ' ' . l:foldSizeStr . ' '
        \ . l:foldLevelStr . ' ' . l:foldPerc . ' ]'
    let l:width = (&textwidth > 0 ? &textwidth : 74)
    let l:expansionString = repeat('·', 
        \ l:width - strwidth(l:left . l:right))
    return l:left . l:expansionString . l:right
endfunction

function! TerseOneFoldText()
    let l:line = getline(v:foldstart)
    " let line = substitute( line, '^[^0-9a-zA-Z]*', '', '' )
    let l:com_str = split(substitute(&commentstring, " ", "", "g" ), "%s")
    let line = substitute(l:line, "" . com_str[0] . "\s*", "", "" )
    " if it's a start/end comment
    if len(line) > 1
        let line = substitute( line, "\s*" . com_str[1], "", "" )
    endif
    let l:fmr = split( &foldmarker, "," )
    let line = substitute( line, "\s*"  . fmr[0] . '\d*\s*', '', '' )

    " number of folded lines
    let len  = v:foldend - v:foldstart
    let depth = v:foldlevel
    let depth_str = ">"
    while depth != 1
        let depth = depth - 1
        let depth_str .= ">"
    endwhile
    return  printf("%-5s", depth_str) . printf("%4d", len) . ': ' . line
endfunction

function! TxtFoldText()
  let level = repeat('-', min([v:foldlevel-1,3])) . '+'
  let title = substitute(getline(v:foldstart), '{\{3}\d\?\s*', '', '')
  let title = substitute(title, '^["#! ]\+', '', '')
  " return printf('%-2s %-s', level, title)
  return printf('[%s][%s]', level, title)
endfunction

function! ToggleTextWidth()
    if &l:textwidth > 0
        let s:old_tw = &l:textwidth
        let &l:textwidth = 0
    else
        if exists('s:old_tw')
            let &l:textwidth = s:old_tw 
        else
            let &l:textwidth = 75
        endif
    endif
endfunction

nnoremap <silent> <leader>v :call ToggleTextWidth()<cr>

" XXX re-enable
" autocmd OptionSet shiftwidth noautocmd 
"       \ let &l:tabstop = &l:shiftwidth | let &l:shiftwidth=0
"

" autocmd BufReadPost * echom string(&shiftwidth).'|'.string(&l:shiftwidth)

" function! Retab(ts)
"     retab!
"     setl noexpandtab
"     let &l:shiftwidth = a:ts 
"     let &l:tabstop = a:ts
"     setl expandtab
" endfunction

function! CompletionChain(findstart, base)
  if a:findstart
    " Test against the functions one by one
    for fcn in g:user_completion_chain
      let pos = call(fcn, [a:findstart, a:base])

      " If a function can complete the prefix,
      " remember the name and return the result from the function
      if pos >= 0
        let s:current_completion = fcn
        return pos
      endif
    endfor

    " No completion can be done
    unlet! s:current_completion
    return -1
  elseif exists('s:current_completion')

    " Simply pass the arguments to the selected function
    return call(s:current_completion, [a:findstart, a:base])
  endif

  return []
endfunction


" 
function! RefreshAppearance()
   if g:within_tmux
      exe 'let $'.system('tmux show-environment COLORSCHEME')
   endif
endfunction

"
function! s:ClearRegisters()
    let l:regs = 'abcdefghijklmnopqrstuvwxyz0123456789*+-'
    for l:r in split(l:regs, '\zs')
        call setreg(l:r, [])
    endfor
endfunction
command! ClearRegisters call s:ClearRegisters()

" requires mtth/vim-scratch XXX WIP
function! ScratchRegister()
    call scratch#open(1)
    exe '0put!'
    " exe '$delete _'
    augroup ScratchRegisterLeave
        autocmd!
        exe 'autocmd WinLeave <buffer='. bufnr('%') . '> %yank'
    augroup END
endfunction

let g:scratch_autohide = 1

" }}}1

" ────────────────────────────────────────────────────────────────────────
"      _____ __        __                       
"     / __(_) /__     / /___  ______  ___  _____
"    / /_/ / / _ \   / __/ / / / __ \/ _ \/ ___/
"   / __/ / /  __/  / /_/ /_/ / /_/ /  __(__  ) 
"  /_/ /_/_/\___/   \__/\__, / .___/\___/____/  
"                      /____/_/                 
" ────────────────────────────────────────────────────────────────────────
" file types {{{1

" this is called before ftplugin stuff so custom maps 
" can be defined on a per file type basis before plugins
function! s:PreFTPlugin(ft)
    let l:au = 'PreFileType_'.a:ft
    if exists('#User#'.l:au)
        exe 'doautocmd User '.l:au
    endif
endfunction

" help
function! s:rc_filetype_help_maps()
    nnoremap <silent><buffer> q :<c-u>bd<cr>
    nnoremap <silent><buffer> K
        \ :<c-u>exe 'topleft help '.scriptease#helptopic()<cr>
endfunction
augroup rc_filetype_help
    au!
    autocmd FileType help if &buftype == 'help'
        \ | call s:rc_filetype_help_maps() | endif
augroup END

" latex
function! s:rc_filetype_tex_maps()
    " vimtex end-wise style end completion
    imap <silent><buffer> <c-x><cr> <plug>(vimtex-delim-close)

    " shift-return alternative: xxx experimental
    execute "set <f26>=\<esc>OM"
    imap <silent><buffer> <f26> <plug>(vimtex-delim-close)
endfunction
augroup rc_filetype_tex
    au!
    autocmd FileType tex call textobj#user#plugin('latex', {
        \  'quote': {
        \     'pattern': ['`', "'"],
        \     'select-a': "a'", 'select-i': "i'",
        \   },
        \  'double-quote': {
        \     'pattern': ['``', "''"],
        \     'select-a': 'a"', 'select-i': 'i"',
        \   },
        \ })
    autocmd FileType tex setlocal iskeyword-=\
    " autocmd FileType tex setlocal iskeyword+=:

    autocmd User PreFileType_tex call s:rc_filetype_tex_maps()
augroup END

" matlab
augroup rc_filetype_matlab
    au!
    autocmd FileType matlab setlocal path+=~/mlpackages
        \ path+=/opt/MATLAB/R2017a/toolbox/matlab/**
        \ commentstring=%\ %s
augroup END

" quickfix
augroup rc_filetype_qf
    au!
    autocmd FileType qf setlocal wrap textwidth=0 nospell
    autocmd FileType qf nnoremap <silent><buffer> q :<c-u>bd<cr>
augroup END
    
" vim
augroup rc_filetype_vim
    au!
    autocmd FileType vim nnoremap <silent><buffer> K
        \ :<C-U>exe 'topleft help '.scriptease#helptopic()<CR>
augroup END


" }}}1

" ────────────────────────────────────────────────────────────────────────
"                     __
"    _______  _______/ /_____  ____ ___     ____ ___  ____ _____  _____
"   / ___/ / / / ___/ __/ __ \/ __ `__ \   / __ `__ \/ __ `/ __ \/ ___/
"  / /__/ /_/ (__  ) /_/ /_/ / / / / / /  / / / / / / /_/ / /_/ (__  )
"  \___/\__,_/____/\__/\____/_/ /_/ /_/  /_/ /_/ /_/\__,_/ .___/____/
"                                                       /_/
" ────────────────────────────────────────────────────────────────────────
" custom maps {{{1

" clear search highlight
nnoremap <silent> <leader>/  :<C-U>nohls<CR>

" toggle airline
nnoremap <silent> <leader>_  :AirlineToggle<CR>

" latex-to-unicode via the julia plugin
nnoremap <expr> <leader>u LaTeXtoUnicode#Toggle()

" default update and compile button (using vim-dispatch)
nnoremap <silent> <leader><leader>  :<C-U>up<CR>:Make!<CR>
nnoremap <silent> <F5>              :<C-U>up<CR>:Make!<CR>

" if current file is executable and has a hashbang, allow it to run
augroup shebang_run
    autocmd!
    autocmd FileType sh     call SetShebangRun()
    autocmd FileType python call SetShebangRun()
    autocmd FileType perl   call SetShebangRun()
augroup END

" paste mode <silent> xxx
nmap  yp <Plug>unimpairedPastea
nmap  yP <Plug>unimpairedPastei

" enable/disable folding
" nnoremap [of :setlocal foldenable<cr>
" nnoremap ]of :setlocal nofoldenable<cr>

" latex stuff
" nnoremap <silent> <leader>lx :<C-U>call SetXeTex()<CR>
" nnoremap <silent> <leader>lz :<C-U>call CompileXeTex()<CR>
" noremap <silent> <leader>le :<C-U>call OpenLog()<CR>

" change to file's directory, locally or globally
nnoremap <silent> <leader>.  :<C-U>lcd %:p:h<CR>:pwd<CR>
nnoremap <silent> g.         :<C-U>cd %:p:h<CR>:pwd<CR>

" tagbar show and hide
nnoremap <silent> <leader>T  :<C-U>TagbarToggle<CR>

" figlet
nnoremap <silent> gy :set operatorfunc=FIGlet#FIGOper<cr>g@
nnoremap <silent> gyy :<c-u>exe 'normal 0gy' . v:count1 . '$'<cr>
nnoremap <silent> gY :FIGlet<cr>
vnoremap <silent> gy :FIGlet<cr>

" XXX better n/vmap for fig picker mode?
" nnoremap <silent> gY :call <sid>FigPickerMode()<cr>

" show syntax under cursor
nnoremap gb :call SyntaxAttr()<cr>
nnoremap gB :echo "hi<"
    \ . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
    \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
    \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>
nmap <silent> g<c-b> :<c-u>HLTX!<cr>
" this one doesn't seem to work
nmap <sid>(hlt) <plug>HiLinkTrace

" free keys xxx
" gb show syntax
" gc tpope/commentary
" gl
" gy figlet
" gz
" zp  << map to window stuff?
" zu
" zy

" latex
augroup filetype_tex
    autocmd!
    autocmd FileType tex nnoremap <silent> <buffer> <leader><bslash>
        \ :<c-u>up<cr>:VimtexCompile<cr>
    autocmd FileType tex nnoremap <silent> <buffer> <F5>
        \ :<c-u>up<cr>:VimtexCompile<cr>
augroup END







    " shortcuts to evaluate vimscript
    autocmd FileType vim nnoremap <silent> <buffer> <leader><bslash>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>
    autocmd FileType vim nnoremap <silent> <buffer> <F5>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>

    autocmd FileType vim vnoremap <silent> <buffer> <leader><bslash>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>
    autocmd FileType vim vnoremap <silent> <buffer> <F5>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>



" TODO: use makeprg for these?
" xxx
" autocmd FileType tex noremap <silent> <leader>\  :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>
" autocmd FileType tex noremap <silent> <F5>       :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>





















" xxx would have to add this compiler back in since removed in vimtex
" autocmd FileType tex compiler latexmk | setl makeprg=latexmk





" function! PickerMode(fname)
"   set cursorline
"   let b:picker_fname = fnamemodify(a:fname, ':p')
"   nmap <buffer> <cr> :call writefile([getline(".")], b:picker_fname)<cr>:qa!<cr>
" endfunction
" command! -nargs=1 PickerMode :call PickerMode(<q-args>)



" \] slings content to tmux pane
nnoremap <silent> <leader>]   :set opfunc=SlingOper<cr>g@
nnoremap <silent> <leader>]]  :silent SlimuxREPLSendLine<cr>
vnoremap <silent> <leader>]   :SlimuxREPLSendSelection<cr>

autocmd FileType matlab nnoremap <silent> 
    \ <leader>\ :<c-u>w<cr>:execute ":SlimuxShellRun " . expand('%:r')<cr>

" yanks to tmux.  can we make this more vimmy?
nnoremap <silent> <leader>y  :.w !tmux loadb -<CR>
vnoremap <silent> <leader>y  :w<home>silent <end> !tmux loadb -<CR>

" toggle syntastic
nnoremap <silent> <leader>s  :<C-U>SyntasticCheck<CR>
nnoremap <silent> <leader>S  :<C-U>call SyntaxToggle()<CR>

" refresh syntax highlighting
nnoremap <silent> <leader>z :<c-u>syntax sync fromstart<cr>


" set pastetoggle=
" set pastetoggle=<leader>`

" unnecessary keys
inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

" easier movement in command mode
cnoremap <c-h> <left>
cnoremap <c-l> <right>
cnoremap <c-x> <s-left>
cnoremap <c-o> <s-right>

" prefix command history
" cnoremap <c-n> <down>
" cnoremap <c-p> <up>

" helpful expansion?
" cnoremap %<tab> <c-r>=expand('%')<cr>
" cabbrev <expr> %% expand('%:h').'/'

" XXX considered harmful?
set <a-b>=b
cnoremap <a-b> <s-left>

set <a-f>=f
cnoremap <a-f> <s-right>

" vdebug
nnoremap <Leader>x :<C-U>VdebugEval 

" quickfix and location lists
nmap <silent> <leader>W :<C-U>call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>Q :<C-U>call ToggleList("Quickfix List", 'c')<CR>

nmap <silent> <leader>w :<C-U>CtrlPLocList<CR>
nmap <silent> <leader>q :<C-U>CtrlPQuickfix<CR>

" general ctrl-p mappings
nmap <silent> <leader>t :<C-U>CtrlPTag<CR>

" xxx these are the same..
nmap <silent> <leader>6 :<C-U>CtrlPBuffer<CR>
nmap <silent> <leader>p :<C-U>CtrlPBuffer<CR>

nnoremap <silent> <leader>[ :<C-U>CtrlPMRUFiles<CR>
nnoremap <silent> <leader>o :<C-U>CtrlP<CR>
nnoremap <leader>O :<C-U>CtrlP 


    " exec 'pedit ' . a:file
    " if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'

    "   " Get the filename
    "   let filename = fnameescape(fnamemodify(a:line, ':p'))

    "   " Close CtrlP
    "   call ctrlp#exit()

    "   " Open the file
    "   silent! execute '!xdg-open' filename

    " elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'

    "   " Not a HTML file, simulate pressing <c-o> again and wait for new input
    "   call feedkeys("\<c-o>")

    " else

    "   " Use CtrlP's default file opening function
    "   call call('ctrlp#acceptfile', [a:action, a:line])

    " endif

nmap <silent> <leader>f :<C-U>call CtrlPCursorFile()<CR>

" open preview window of file under cursor (doesn't always work)
" nmap <silent> <leader>o :<C-U>exec 'pedit ' . expand('<cfile>') <CR><C-W>P
" was <tab> but this conflictrs
"

"" autocmd FileType matlab nnoremap <buffer> <leader>\ :make<CR><CR>
"" autocmd FileType matlab set makeprg=mluxrun\ %:r

" autocmd FileType matlab nnoremap <buffer> K :Mhelp <C-R>=expand('<cword>')<CR><CR>



" normal available: Ctrl-@ Ctrl-X Ctrl-K Ctrl-\ Ctrl-_ 

" increment/decrement
set nrformats+=alpha

" bootleq/vim-cycle
let g:cycle_no_mappings = 1
nmap <leader><c-a> <Plug>CycleNext
nmap <leader><c-x> <Plug>CyclePrev
let g:cycle_default_groups_for_tex = [
    \   [[ '[\big]', '[\Big]', '[\bigg]', '[\Bigg]' ], 
        \ 'match_case', 'hard_case'],
    \ ]

" AndrewRadev/switch.vim
let g:switch_mapping = ''
let g:switch_custom_definitions = [
    \   { '\(\w\)\(\[[bB]ig\{1,2}\]\)\({\)': '\1\3' },
    \ ]



    " \   [['\big\l:\big\r', '\Big\l:\Big\r', '\bigg\l:\bigg\r', 
    "     \ '\Bigg\l:\Bigg\r'], 'sub_pairs', 'hard_case', 'match_case'],
    " \ ]

" function! KonsoleSetBg(hex)
"     call system("/home/andy/script/bgchange.sh 292D3E")
" endfunction

" these can be repeated with '.' so don't really need to be easy to hit
nnoremap <leader>, <c-x>
vnoremap <leader>, <c-x>
vnoremap g<leader>, g<c-x>
nnoremap <leader>; <c-a>
vnoremap <leader>; <c-a>
vnoremap g<leader>; g<c-a>

nnoremap <silent> <plug>(tex-opt-incr) :<c-u>call TexOptionIncrement(1)<cr>
nnoremap <silent> <plug>(tex-opt-decr) :<c-u>call TexOptionIncrement(-1)<cr>
nmap <silent> co <plug>(tex-opt-incr)
nmap <silent> cO <plug>(tex-opt-decr)

" nnoremap <c-k> <c-a>
" nnoremap <c-j> <c-x>
" vnoremap <c-k> <c-a>
" vnoremap <c-j> <c-x>
" vnoremap g<c-k> g<c-a>
" vnoremap g<c-j> g<c-x>

" tex increment option ('' = \relax)
let g:tex_big_list = [ '', '\big', '\Big', '\bigg', '\Bigg' ]
function! TexOptionIncrement(dir)
    let l:cur = vimtex#cmd#get_current()
    if empty(l:cur) | return 0 | endif

    " handles the case where cursor is on [\big]
    if index(g:tex_big_list, l:cur.text) >= 0
        let l:cur = vimtex#cmd#get_at([l:cur.pos_end.lnum, 
            \ l:cur.pos_end.cnum+1])
        if empty(l:cur) | return 0 | endif
    endif

    let l:direction = a:dir < 0 ? -v:count1 : v:count1

    " if already has [something]
    if !empty(l:cur.opt)
        let l:opttext = substitute(l:cur.opt.text, '\s\+$', '', '')
        let l:idx = index(g:tex_big_list, l:opttext)
        if l:idx < 0 | return 0 | endif

        let l:idx2 = (l:idx+l:direction) % len(g:tex_big_list)
        let l:new = g:tex_big_list[l:idx2]

        let l:start = l:cur.opt.open.cnum
        let l:end = l:cur.opt.close.cnum-1

        if !strlen(l:new)
            let l:start -= 1
            let l:end += 1
        endif
    else
        let l:idx2 = (0+l:direction) % len(g:tex_big_list)
        let l:new = l:idx2 > 0 ? '['.g:tex_big_list[l:idx2].']' : ''
        let l:start = len(l:cur.args) ? l:cur.args[0].open.cnum-1
            \ : l:cur.pos_end.cnum
        let l:end = l:start
    endif

    let l:pos = getcurpos()
    let l:line = getline('.')
    let l:before_text = strpart(l:line,0,l:start)
    let l:after_text = strpart(l:line,l:end)
    silent call setline('.',l:before_text.l:new.l:after_text)
    call setpos("'[",[0,line('.'),strlen(l:before_text)+1,0])
    call setpos("']",[0,line('.'),l:start+strlen(l:new),0])

    if l:pos[2] > l:start
        let l:newcol = l:pos[2] + strlen(l:new) - (l:end - l:start)
        let l:pos[2] = max([l:start, l:newcol])
        let l:pos[4] = l:pos[2]
        call setpos('.', l:pos)
    endif

    silent! call repeat#set("\<plug>".'(tex-opt-'
        \ .(a:dir < 0 ? 'decr' : 'incr').')', v:count)

    return 1
endfunction

" function s:SID()
"     return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
" endfun

" function! WordIncrement(direction)
"     let l:pat = '\V'.escape(join(
"         \ map(g:tex_big_list, 'v.val."d"'), '\|'), '\')

"     let l:line = getline('.')
"     let l:start = 0
"     while l:start >= 0 
"         let l:match = matchstrpos(l:line, l:pat, l:start)
"         let l:curp = col('.') + (mode() == 'i' ? -1 : 0)
"         if l:curp > l:match[1] && l:curp <= l:match[2]
"             let idx = index(match[0], "the")
"         endif

"         let l:start = l:match[2]
"    endwhile

"    let l:before_text = strpart(l:line,0,l:start)
"    let l:after_text = strpart(l:line,l:end)
"    silent call setline('.',l:before_text.l:new.l:after_text)
"    call setpos("'[",[0,line('.'),strlen(l:before_text)+1,0])
"    call setpos("']",[0,line('.'),l:start+strlen(l:new),0])
" endfunction


" shortcut to repeat macro (this is also control-space)
nnoremap <c-@> @@


" ctrl a conflicts with tmux
nnoremap <c-a> <nop>

" go to end of current word and start completion
function! s:EndOfWord()
    call search('\w\>','cW')
endfunction
nmap <silent> <c-x> :call <sid>EndOfWord()<cr>a<f19>

" g:ycm_key_invoke_completion
imap <c-l> <f19>

" or use chrisbra/unicode.vim
" convert :emoji: under or next to the cursor to the appropriate emoji
" works in normal mode or insert mode
" TODO: support visual mode
function! EmojiReplace()
   let l:pat = ':\([^:]\+\):'
   let l:line = getline('.')
   let l:start = 0
   while l:start >= 0 
      let l:match = matchstrpos(l:line, l:pat, l:start)
      let l:curp = col('.') + (mode() == 'i' ? -1 : 0)
      if l:curp > l:match[1] && l:curp <= l:match[2]
         let l:em = substitute(l:match[0], 
            \ l:pat, '\=emoji#for(submatch(1))', '')
         if !len(l:em)
            return 0
         endif

         call cursor(0, 1+l:match[1])
         if mode() == 'i'
            let l:line = strpart(l:line, 0, l:match[1])
                     \ . l:line[l:match[2]:]
            call setline('.', l:line)
            call feedkeys(l:em)
         else
            let l:line = strpart(l:line, 0, l:match[1])
                     \ .l:em . l:line[l:match[2]:]
            call setline('.', l:line)
         endif

         " exe 'normal! '.(l:match[1]+1).'|'
         " exe 'normal! v'.l:match[2].'|c'.l:em
         return ''
      endif
      let l:start = l:match[2]
   endwhile
   return 0
endfunction

" TODO allow repeat
nnoremap <silent> gl :call EmojiReplace()<cr>

" au CompleteDone * if len(v:completed_item) > 1 | call EmojiReplace() | endif


inoremap <c-f> <c-r>=EmojiReplace()<cr>
" inoremap <c-f> <left><c-\><c-o>:call EmojiReplace()<cr><right>


"nnoremap <silent> gl :s/:\([^:]\+\):/\=emoji#for(submatch(1), submatch(0))/g<cr>
" nnoremap <silent> gl :s/:\([^:]\+\):/\=
"     \ emoji#for(submatch(1), submatch(0))/e<cr>:nohls<cr>
" vnoremap <silent> gl :s/:\([^:]\+\):/\=
"     \emoji#for(submatch(1), submatch(0))/ge<cr>:nohls<cr>

" ycm goto
nnoremap <leader>d :YcmCompleter GoTo<CR>

" search for cursor word without jumping
function! SearchWord()
    let @/ = '\<'.escape(expand('<cword>'), 
        \ &magic ? "/.*~[^$\\" : "/^$\\").'\>'
endfunction
nnoremap <silent> <leader>* :call SearchWord() \| set hlsearch<cr>

" change cursor word and load search to quickly change occurrences
" dot can be used to repeat the search+change combo
nnoremap <leader>c :call SearchWord() \| set hlsearch<cr>cgn

" xxx experimental
" nnoremap <silent> <space>+
"     \ <c-w>+:call repeat#set("<c-v><c-w>+", v:count)<cr>
" nnoremap <silent> <space>-
"     \ <c-w>-:call repeat#set("<c-v><c-w>-", v:count)<cr>
" nnoremap <silent> <space><lt>
"     \ <c-w><lt>:call repeat#set("<c-v><c-w><lt>", v:count)<cr>
" nnoremap <silent> <space>>
"     \ <c-w>>:call repeat#set("<c-v><c-w>>", v:count)<cr>

" reload vimrc
nnoremap <silent> <leader>` :ReloadVimrc<cr>
nnoremap <silent> <leader>~ :PlugUpdate<cr>


" XXX experimental (does this break copy paste in tmux??)
" see: sjl/vitality.vim, tmux-plugins/vim-tmux-focus-events,
" amerlyq/vim-focus-autocmd wincent/terminus
function! SetupFocusReporting()
    let save_screen = "\<Esc>[?1049h"
    let restore_screen = "\<Esc>[?1049l"
    let tmux_start = "\<Esc>Ptmux;"
    let tmux_end = "\<Esc>\\"
    let enable_focus_reporting = "\<Esc>[?1004h"
    let escaped_enable_focus_reporting = tmux_start
                \ . "\<Esc>" . enable_focus_reporting
                \ . tmux_end
                \ . enable_focus_reporting
    let disable_focus_reporting = "\<Esc>[?1004l"

    let &t_ti = escaped_enable_focus_reporting . save_screen
    let &t_te = disable_focus_reporting . restore_screen
    exec "set <F24>=\<Esc>[O"
    exec "set <F25>=\<Esc>[I"

    nnoremap <silent> <f24> :silent doautocmd FocusLost %<cr>
    nnoremap <silent> <f25> :silent doautocmd FocusGained %<cr>

    onoremap <silent> <f24> <esc>:silent doautocmd FocusLost %<cr>
    onoremap <silent> <f25> <esc>:silent doautocmd FocusGained %<cr>

    vnoremap <silent> <f24> <esc>:silent doautocmd FocusLost %<cr>gv
    vnoremap <silent> <f25> <esc>:silent doautocmd FocusGained %<cr>gv

    inoremap <silent> <f24> <c-\><c-o>:silent doautocmd FocusLost %<cr>
    inoremap <silent> <f25> <c-\><c-o>:silent doautocmd FocusGained %<cr>

    cnoremap <silent> <f24> <c-\>e<SID>DoCmdModeFocus('FocusLost')<cr>
    cnoremap <silent> <f25> <c-\>e<SID>DoCmdModeFocus('FocusGained')<cr>
endfunction

function! s:DoCmdModeFocus(event)
    let cmd = getcmdline()
    let pos = getcmdpos()
    exec 'silent doautocmd '.a:event.' %'
    call setcmdpos(pos)
    return cmd
endfunction

if g:within_tmux
    call SetupFocusReporting()
endif


" XXX smart-ish re-layout
" this has the nice properties of mostly preserving order,
" but does not swap out to master correctly
function! Relayout()
   let l:nr = winnr()
   let l:nrlast = winnr('#')
   windo wincmd J
   exe l:nrlast.'wincmd w'
   exe l:nr.'wincmd w'
   if &columns > (&textwidth)+20
      wincmd H
   else
      wincmd K
      wincmd _
   endif
endfunction
" nnoremap <silent> <c-w><space> :call Relayout()<cr>

command! -nargs=* LayoutH call window#layout('ball', 'H', <args>)
nnoremap <c-w><space> :<c-u>LayoutH v:count<cr>
nnoremap <C-w>gl :<C-U>call window#join('rightbelow vsplit', v:count) <BAR>normal! 100zh<CR>
nnoremap <C-w>gh :<C-U>call window#join('leftabove vsplit', v:count)  <BAR>normal! 100zh<CR>
nnoremap <C-w>gj :<C-U>call window#join('belowright split', v:count)  <BAR>normal! 100zh<CR>
nnoremap <C-w>gk :<C-U>call window#join('aboveleft split', v:count)   <BAR>normal! 100zh<CR>
nnoremap <C-w>e :<C-U>call window#exchange(v:count)<cr>

" sanity
" stack
" bi-stack
" tri-stack
" accordionize
" by name
" option: ball or only visible

" using wincmd allows us to repeat with @: (XXX but wait not actually...?)
" nmap , :5wincmd <<cr>
" nmap . :5wincmd ><cr>

let g:res_ver_increm = round(&columns*0.03)
let g:res_hor_increm = round(&lines*0.08)

nnoremap <silent> , :vertical res -5<cr>
nnoremap <silent> . :vertical res +5<cr>
nnoremap <silent> < :vertical res -1<cr>
nnoremap <silent> > :vertical res +1<cr>
nnoremap <silent> - :res -3<cr>
nnoremap <silent> = :res +3<cr>
nnoremap <silent> _ :res -1<cr>
nnoremap <silent> + :res +1<cr>

" nnoremap gl :exe 'echo '.v:count<cr>

set noequalalways  " window management
" set eadirection=ver,hor,both

" enough for 3 windows stacked vertically with LINES=38, winminheight=1
" set winheight=32 winwidth=16
set winheight=20 winwidth=16
set winminheight=1 winminwidth=0

let g:windowswap_map_keys = 0
" XXX better keymaps?
"     why doesn't airline work with this?
" nnoremap <c-w>m :call WindowSwap#MarkWindowSwap()<CR>
" nnoremap <c-w>' :call WindowSwap#DoWindowSwap()<CR>

" see airline extension for windowing

" comma join
nnoremap <silent> <leader>J :Join ', '<cr>
vnoremap <silent> <leader>J :Join ', '<cr>

" zero-paste: convert register to character-wise
function! ZeroPaste(p)
    call setreg(v:register, getreg(v:register), 'c')
    exe 'normal "'.v:register.a:p
endfunction
nnoremap <silent> zp :<c-u>call ZeroPaste('p')<cr>
nnoremap <silent> zP :<c-u>call ZeroPaste('P')<cr>

" change-paste: like visual paste but preserves " register
" usually want cpw/cpiw 
" the removed text goes into the "- register
" repeat already works
function! ChangePasteOp(motionType)
    let l:save = @"
    let l:reg = s:change_paste_register
    if l:reg == '='
        let @" = getreg(s:change_paste_register)
        let l:reg = '"'
    endif
    if s:EmptyRegion()
        normal! `]
    elseif a:motionType == 'line'
        normal! '[V']
    elseif a:motionType == 'char'
        normal! `[v`]
    endif
    exe 'normal! "'.l:reg.'p'
    let @" = l:save
    if maparg('w', 'o') == maparg('<sid>(cp-w-oper)', 'o')
        ounmap w
    endif
endfunction

function! s:EmptyRegion()
    let l:begin = getpos("'[")
    let l:end = getpos("']")
    return l:begin[1] == l:end[1] && l:end[2] < l:begin[2]
endfunction

" self-destructing omap
onoremap <expr> <sid>(cp-w-oper) <sid>ChangePasteW()
function! s:ChangePasteW()
    if &operatorfunc == 'ChangePasteOp' && v:operator == 'g@'
        return 'e'
    endif
    if maparg('w', 'o') == maparg('<sid>(cp-w-oper)', 'o')
        ounmap w
    endif
    return 'w'
endfunction

" set up change-paste
function! s:ChangePaste()
    set operatorfunc=ChangePasteOp
    let s:change_paste_register = v:register
    if maparg('w', 'o') == ""
        exe 'onoremap <expr> w '.maparg('<sid>(cp-w-oper)', 'o')
    endif
    return 'g@'
endfunction
nnoremap <expr> <sid>(cp-start) <sid>ChangePaste()
nmap <silent> cp <sid>(cp-start)

nmap <silent> cpp cp_
nmap <silent> cP cp$

" special case similar to cw
nmap <silent> cpw cpe

" vinegar
" nmap <leader>- <Plug>VinegarSplitUp
nmap <leader>- <Plug>VinegarUp

" do not let vinegar override this map 
" nnoremap - -

" iabbr <expr> ]] vimtex#delim#close()
" imap <f26> <plug>(vimtex-delim-close)

" todo
" ViewDocWrapper preserve registers
" ViewDoc for other file types

" a somewhat more useful go-to-middle of text
nnoremap <silent> gM gm
nnoremap <silent> gm :exe 'normal '.float2nr(&tw/2).'\|'<cr>

" }}}1

" final setup
call SiteSetupPost()

function! FixIndents()
    call SecureModelines_DoModelines()
    echo &et &ts &sw &sts &sta
endfunction

function! s:init()
    call SiteEnter()

    " add a hook to securemodelines
    if get(g:, 'loaded_securemodelines', 0)
        augroup SecureModeLines
            au!
            " au BufRead,StdinReadPost * call FixIndents()
        augroup END
    endif

    " undo vim-vinegar's default map
    if get(g:, 'loaded_vinegar', 0) && maparg('-', 'n') != ''
        unmap -
    endif

    " XXX testing
    if g:rc_disable_youcompleteme
        let g:latex_to_unicode_suggestions = 1
    endif
endfunction

if v:vim_did_enter
    call s:init()
else
    au VimEnter * nested call s:init()
endif

set secure

" vim: sw=4

