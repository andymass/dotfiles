" ────────────────────────────────────────────────────────────────────────
"       ___              __     _                _
"      /   |  ____  ____/ /_  _( )_____   _   __(_)___ ___  __________
"     / /| | / __ \/ __  / / / /// ___/  | | / / / __ `__ \/ ___/ ___/
"    / ___ |/ / / / /_/ / /_/ / (__  )   | |/ / / / / / / / /  / /__
"   /_/  |_/_/ /_/\__,_/\__, / /____/    |___/_/_/ /_/ /_/_/   \___/
"                      /____/
" ────────────────────────────────────────────────────────────────────────

" overview {{{1
" \\, <f5>,     update and compile document (filetype dependent)
" \=, \-
" \g=, \g-      increment, decrement
" \.            locally change directory
" \/            remove highlight
" \[            CtrlP mru
" \]{motion},
" \]],
" {Visual}\],   Sling to tmux
" \a
" \b
" \c
" \d            YcmDiagnostic
" \e
" \f            CtrlP to file under cursor
" \g            :Ag prompt
" \G            Ag file under cursor
" \h
" \i
" \j
" \k
" \l            vimtex
" \m
" \n
" \o            CtrlP (all files in directory)
" \p            CtrlP buffers
" \q            CtrlP quickfix
" \Q            Toggle quickfix
" \r
" \s            Syntax check
" \S            Syntax toggle
" \t            CtrlP tags
" \T            Toggle tagbar
" \u            Toggle latex-to-unicode
" \v
" \w            CtrlP locations
" \W            Toggle location list
" \x            :VdebugEval prompt
" \y            Yank to tmux
" \z            Re-sync syntax highlighting
"
" gy{motion},
" gyy,
" {Visual}gy    figlet  
" gY            figlet font picker
" g.            globally change directory
" gb, gB        show syntax under cursor
"
" yp, yP        open line and set paste (above, below)
"

" Todo
"   - ripgrep
"   - syntastic -> ale
"   - vdebug

" }}}1

" the basics {{{1
set nocompatible
set ts=4
set sw=0
set textwidth=75
set wm=2
set cc=+1
set expandtab
set bs=indent
set ffs=unix,dos

set noswapfile
set virtualedit=block

set ttimeout ttimeoutlen=100
set mouse=a

set nu
set hlsearch
set spell spelllang=en_us
set spellsuggest=best,5
set thesaurus=~/.vim/config/mthesaur.txt
" set dictionary=/usr/share/dict/words

" j: remove comments when joining
" l: don't break long lines in insert mode
set formatoptions+=jl

" changes the behavior of <cr> in two ways:
"   - <cr> now accepts an autocomplete
"   - <cr> starts a new undo sequence
"   xxx conflicts with ycm
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" set fillchars=vert:║,fold:- ─
set fillchars=stl:\ ,stlnc:\ ,fold:\ ,vert:│
set listchars=trail:·
let &showbreak = ' → '

set laststatus=2
set scrolloff=2
set wildmenu
set wildmode=longest:full,full
set suffixes+=.pdf,.synctex
set isfname-==

set splitbelow
set splitright
set switchbuf=useopen,split
set previewheight=18

set nomodeline
" set modelines=0
set infercase

set nosol

" under ssh, disable clipboard to make things faster
if $SSH_CLIENT != ''
    set clipboard=exclude:.*
endif

autocmd FileType qf setlocal wrap | nnoremap <silent> <buffer> q :q<cr>

" matlab
set path+=~/mlpackages
" TODO: matlab don't spell comments?

" use ag for grepping
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --smart-case\
        \ --column\ --follow\ -C0
    set grepformat=%f:%l:%c:%m
    command! -nargs=+ -complete=file -bar
        \ Ag silent! grep! <args>|cwindow|redraw!
endif

if exists(':Ag')
    nnoremap <leader>G :execute "Ag " . expand("<cword>") <cr>
    nnoremap <leader>g :Ag 
endif



let g:config_home = expand('~/.vim/config')
autocmd BufRead .vimrc exe 'setl path+='.g:config_home

let g:within_tmux = ($TMUX != '')

" }}}1

" ────────────────────────────────────────────────────────────────────────
"             __            _
"      ____  / /_  ______ _(_)___  _____
"     / __ \/ / / / / __ `/ / __ \/ ___/
"    / /_/ / / /_/ / /_/ / / / / (__  )
"   / .___/_/\__,_/\__, /_/_/ /_/____/
"  /_/            /____/
" ────────────────────────────────────────────────────────────────────────
" plugins {{{1

" ~/.vim/config/plugs.vim
execute 'source' g:config_home.'/plugs.vim'

if !exists("g:colors_name")

endif

" colorscheme setup
" set background=dark
" if !$NO_COLORSCRIPT && &term !~ 'putty'
" "   setting shell path is not necessary
" "    let g:base16_shell_path='~/scripts/base16-shell/'
"     let base16colorspace=256
" endif
" colorscheme base16-eighties
" colorscheme nord
" let g:airline_theme = 'nord'

" jump to the last position in file when reopening
augroup vim_startup
    autocmd!
    autocmd BufReadPost * 
        \ if line("'\"") > 0 && line("'\"") <= line("$")
        \| exe "normal! g'\"" | endif
augroup END

" allows cursor change in tmux mode
if exists('$TMUX')
    let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
    let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
    let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
else
    let &t_SI = "\<Esc>]50;CursorShape=1\x7"
    let &t_EI = "\<Esc>]50;CursorShape=0\x7"
    let &t_SR = "\<Esc>]50;CursorShape=2\x7"
endif

" transparent background
if !has("gui_running")
    hi Normal ctermbg=none
end

" disable intro
set shortmess+=I

" }}}1

" ────────────────────────────────────────────────────────────────────────
"            __            _                      __  _
"     ____  / /_  ______ _(_)___     ____  ____  / /_(_)___  ____  _____
"    / __ \/ / / / / __ `/ / __ \   / __ \/ __ \/ __/ / __ \/ __ \/ ___/
"   / /_/ / / /_/ / /_/ / / / / /  / /_/ / /_/ / /_/ / /_/ / / / (__  )
"  / .___/_/\__,_/\__, /_/_/ /_/   \____/ .___/\__/_/\____/_/ /_/____/
" /_/            /____/                /_/
" ────────────────────────────────────────────────────────────────────────
" plugin options {{{1

" vimtex {{{2

" autocmd FileType tex :iabbr <buffer> ... \dots

let g:vimtex_view_forward_search_on_start = 0
let g:vimtex_imaps_leader = '`'
let g:vimtex_indent_ignored_envs = ['document', 'aligned']

" }}}2

" ultisnips {{{2
let g:UltiSnipsSnippetDirectories=["ultisnips"]
let g:UltiSnipsExpandTrigger='<c-t>'
let g:UltiSnipsJumpForwardTrigger='<c-t>'
let g:UltiSnipsJumpBackwardTrigger='<c-d>'

" let g:UltiSnipsListSnippets

" let g:vimtex_imaps_snippet_engine = 'ultisnips'
    " \ 'leader' : 0, 
 
" }}}2

" call vimtex#imaps#add_map({
"     \ 'lhs' : 'test',
"     \ 'rhs' : '\tested',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})
"

" control space
" let g:vimtex_imaps_leader = "<c-@>

" call vimtex#imaps#add_map({
"     \ 'lhs' : '{',
"     \ 'rhs' : '{}',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})

" function! vimtex#imaps#wrap_math(lhs, rhs) " 
"       return s:is_math() ? a:rhs : a:lhs
"   endfunction

"" %! TeX program=XeLaTeX
" function! DetectTexProgram()

"   let l:pat = '^\c\s*%\s*!\?\s*tex\s\+\(TS-\)\?program\s*=\s*\zs.*\ze\s*$'
"   let l:engine_list = {
"       \ 'pdflatex'         : '',
"       \ 'lualatex'         : '-lualatex',
"       \ 'xelatex'          : '-xelatex',
"       \ 'context (luatex)' : '-pdflatex=context',
"       \ 'context (pdftex)' : '-pdflatex=''texexec --xtx''',
"       \ 'context (xetex)'  : '-pdflatex=texexec',
"       \  }

"       " \ 'pdftex'           : 'pdftex',
"       " \ 'luatex'           : 'luatex',
"       " \ 'xetex'            : 'xetex',

"   for l:line in getline(1, 5)
"     let l:engine = matchstr(l:line, l:pat)
"     if len(l:engine) > 0
"       if has_key(l:engine_list, tolower(l:engine)) > 0
"         let l:opt = ' '.l:engine_list[tolower(l:engine)].' '
"         let g:vimtex_latexmk_options .= l:opt
"       else
"         echoerr 'Unknown engine '.l:engine
"       endif
"     endif
"   endfor

" endfunction

" autocmd FileType tex call DetectTexProgram()


" if has("autocmd") && exists("+omnifunc")
"     autocmd Filetype *
"         \   if &omnifunc == "" |
"         \       setlocal omnifunc=syntaxcomplete#Complete |
"         \   endif
" endif


" xxx where should this be?
let g:user_completion_chain = [ 
     \ 'emoji#complete', 
     \ 'syntaxcomplete#Complete' ]

" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=MyComplete |
"     \   endif

function! EmoComplete(findstart, base)
    echo a:findstart
    sleep 1
    echo a:base
    sleep 1
    " echo emoji#complete(a:findstart, a:base)
    " sleep 2
    return emoji#complete(a:findstart, a:base)
endfunction

" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=EmoComplete |
"     \   endif

" SuperTab?
" if &omnifunc == ""
    " setlocal omnifunc=MyComplete
    " setlocal omnifunc=emoji#complete
" endif

autocmd Filetype * if &omnifunc == "" 
    \ |     setlocal omnifunc=syntaxcomplete#Complete
    \ | endif


for f in glob(g:config_home.'/site.'.hostname().'.vim', 1, 1)
    exec 'source' f
endfor

" gutentags {{{2
let g:gutentags_project_root = [ 'latexmkrc' ]
let g:gutentags_generate_on_new = 0
let g:gutentags_generate_on_missing = 0
let g:gutentags_generate_on_write = 0

" let g:gutentags_project_root = ['tags'] 
" let g:gutentags_add_default_project_roots = 0
" let g:gutentags_cache_dir = '/home/andy/.cache/gutentags'
"}}}2

" netrw/vim-vinegar {{{2
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
"}}}2

" airline {{{2
let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : 'N',
      \ 'i'  : 'I',
      \ 'R'  : 'REPLACE',
      \ 'v'  : 'V',
      \ 'V'  : 'V-LINE',
      \ 'c'  : 'CMD',
      \ '' : 'V-BLOCK',
      \ }

let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_alt_sep = ''

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = '🔒'   " 
let g:airline_symbols.linenr = ''
let g:airline_symbols.paste = '🐧'   	" hhp
let g:airline_symbols.whitespace = 'w'

let g:airline_symbols.notexists = ' 🚫'
" let g:airline_symbols.modified = 'm'
" let g:airline_symbols.modified = ' 💡'
" let g:airline_symbols.space = '~'
" let g:airline_symbols.crypt = "\xf0\x9f\x94\x92"



let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#bufferline#enabled = 0
let g:airline#extensions#syntastic#enabled = 1
let g:airline#extensions#tagbar#enabled = 1

" xxx
" let g:airline#extensions#tagbar#flags = 'p'

let g:airline#extensions#vimtex#enabled = 0

let g:airline_section_error = ''  " temporary, to hide red arrow
let g:airline_section_warning = ''
" let g:airline_skip_empty_sections = 1
  

if 0


function! _ShortenDir()
    return substitute(fnamemodify(getcwd(),':~:.'),'\~/Dropbox','DB','')
endfunction

let g:airline_section_b = "%<%{_ShortenDir()}/"
let g:airline_section_x = '%{airline#extensions#tagbar#currenttag()}' 
let g:airline_section_y = '%{airline#parts#filetype()}'
let g:airline_section_z = '%p%% %#__accent_bold#%l%#__restore__#:%2v'
" let g:airline_section_warning = ''
" let g:airline_section_gutter = ''

let g:airline#extensions#default#section_truncate_width = {
  \ 'b': 79, 'x': 60, 'y': 60, 'z': 45 }

" there is a base16_eighties theme but it maps normal mode to green
" see https://github.com/vim-airline/vim-airline/issues/1067
"" let g:airline_theme = 'base16'

endif


" }}}2

" viewdoc {{{2
" XXX
let g:viewdoc_open = 'topleft new'
let g:ViewDoc_tex = 'ViewDoc_help_custom' 
" let g:viewdoc_only = 1

" default to ViewDocHelp!
let g:no_viewdoc_abbrev = 1
cnoreabbrev <expr> h      getcmdtype()==':'
    \ && getcmdline()=='h'     ? 'ViewDocHelp!' : 'h'
cnoreabbrev <expr> help   getcmdtype()==':'
    \ && getcmdline()=='help'  ? 'ViewDocHelp!' : 'help'

"}}}2

" quickscope {{{2
let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

"}}}2
"
" latex / latex-suite (vimlatex)
" autocmd FileType tex setlocal iskeyword+=:
autocmd FileType tex setlocal iskeyword-=\

let g:Tex_Leader2='<C-\>'

let g:tex_flavor='latex'
let g:Tex_AutoFolding=0
let g:Tex_ShowErrorContext=0
let g:tex_comment_nospell=1
let g:Imap_FreezeImap=1
let g:Tex_EnvironmentMaps=0
let g:Tex_EnvironmentMenus=0

let g:Tex_DefaultTargetFormat='pdf'
let g:Tex_MultipleCompileFormats='pdf'
" let g:Tex_ViewRule_pdf='zathura -x "gvim+%{line} %{input}"'
" TODO: right now we save this only for tex files
function! SynctexInverseSearch(line, file)
    echo a:file
    " let bufnr = bufnr('^'.a:file.'$')
    " exe bufwinnr.'winc w'
endfunction
autocmd FileType tex let $VIM_SERVERNAME=v:servername

let g:Tex_ViewRuleComplete_pdf='zathura -x '
    \ . '"vim --servername {v:servername} --remote +\%{line} \%{input}" '
    \ . '$*.pdf 2>/dev/null &'
let g:Tex_ViewRule_pdf='synctex_wrapper'

let g:Tex_CompileRule_pdf='pdflatex -synctex=-1 -interaction=nonstopmode -file-line-error-style $* -max-print-line=255 -shell-escape'
function! SetXeTex()
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
endfunction

function! CompileXeTex()
    let oldCompileRule=g:Tex_CompileRule_pdf
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
    call Tex_RunLaTeX()
    let g:Tex_CompileRule_pdf=oldCompileRule
endfunction

autocmd BufNewFile,BufRead *.tex 
    \ if getline(1) =~? 'xetex\|xelatex' | call SetXeTex() | endif

function! OpenLog()
	let mainfname = Tex_GetMainFileName()
	let mfnlog = fnamemodify(mainfname, ":t:r").'.log'
    execute 'split '.mfnlog
endfunction

" vdebug
let g:vdebug_keymap = {
    \    "run" : "<F13>", 
    \    "run_to_cursor" : "<Leader>R",
    \    "step_over" : "<F2>",
    \    "step_into" : "<F3>",
    \    "step_out" : "<F4>",
    \    "close" : "<Leader>c",
    \    "detach" : "<F7>",
    \    "set_breakpoint" : "<F10>",
    \    "get_context" : "<Leader>w",
    \    "eval_under_cursor" : "<Leader>v",
    \    "eval_visual" : "<Leader>e",
    \}



" vimtex
let g:vimtex_compiler_latexmk = {
    \   'backend'    : 'jobs',
    \   'background' : 1,
    \   'continuous' : 0, 
    \   'callback'   : 0
    \}

let g:vimtex_view_automatic = 0
let g:vimtex_view_method = 'zathura'
let g:vimtex_quickfix_open_on_warning = 0

let g:vimtex_quickfix_latexlog = {
    \ 'overfull' : 0,
    \ 'underfull' : 0,
    \}

" let g:vimtex_latexmk_continuous = 0
" let g:vimtex_latexmk_background = 1
" let g:vimtex_quickfix_ignore_all_warnings = 0
" let g:vimtex_latexmk_build_dir='build'
" function! SetBuildDir()
 "    let g:vimtex_latexmk_build_dir='build'
" endfunction
" augroup vimtex_config
 "    au!
 "    au User VimtexEventInitPost call SetBuildDir()
" augroup END

" zotero + betterbibtex
augroup filetype_tex_b
    autocmd!
    autocmd FileType tex nnoremap <silent> <leader>c :r!cite<cr>
augroup END

" vimtex + surround
augroup latex_surround
   autocmd!
   autocmd FileType tex call s:latexSurround()
augroup END

function! s:latexSurround()
   let b:surround_{char2nr("e")}
     \ = "\\begin{\1environment: \1}\n\t\r\n\\end{\1\1}"
   let b:surround_{char2nr("c")} = "\\\1command: \1{\r}"
endfunction

" vimtex + ycm
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
    \ 're!\\[A-Za-z]*cite[A-Za-z]*(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\[A-Za-z]*ref({[^}]*|range{([^,{}]*(}{)?))',
    \ 're!\\hyperref\[[^]]*',
    \ 're!\\includegraphics\*?(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\(include(only)?|input){[^}]*',
    \ 're!\\\a*(gls|Gls|GLS)(pl)?\a*(\s*\[[^]]*\]){0,2}\s*\{[^}]*',
    \ 're!\\includepdf(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\includestandalone(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\usepackage(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\documentclass(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\[A-Za-z]*',
    \ ]

let g:ycm_key_invoke_completion = '<f19>'
" let g:ycm_cache_omnifunc = 0

function! VimtexHelpLookup()
    let l:start = vimtex#complete#omnifunc(1, [])
    let l:cword = expand('<cword>')
    let l:cword = substitute(l:cword, '^\\', '', '')
    let l:candidates = vimtex#complete#omnifunc(0, l:cword.'\>')
    if empty(l:candidates)
        echom 'nothing'
    else
        let l:pkgname = matchlist(l:candidates[0].menu, 
            \ '\v\[cmd:\s+(.+)\]')[1]
        echom l:pkgname
    end
endfunction

" nnoremap K :call VimtexHelpLookup()<cr>


" xxx this is bad, fix
let g:ycm_semantic_triggers.text = [ 
    \ 're!:arrow',
    \ ]

" CompleteDone
" set completefunc=emoji#complete

let g:ycm_filetype_blacklist = {
    \ 'tagbar'   : 1,
    \ 'qf'       : 1,
    \ 'notes'    : 1,
    \ 'markdown' : 1,
    \ 'unite'    : 1,
    \ 'vimwiki'  : 1,
    \ 'pandoc'   : 1,
    \ 'infolog'  : 1,
    \ 'mail'     : 1,
    \ 'netrw'    : 1,
    \ }

" CtrlP {{{2
let g:ctrlp_extensions = [ 'tag', 'quickfix' ]
    " 'tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
    " \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']

if executable('ag')
    let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
          \ --ignore .git
          \ --ignore .svn
          \ --ignore .hg
          \ --ignore .DS_Store
          \ --ignore "**/*.pyc"
          \ --ignore $HOME/.cache
          \ -g ""'
endif

let g:ctrlp_clear_cache_on_exit = 1

let g:ctrlp_map = ''
let g:ctrlp_cmd = 'CtrlPMRUFiles'
let g:ctrlp_prompt_mappings = {
    \ 'PrtClearCache()':      ['<c-g>'],
    \ 'ToggleByFname()':      ['<c-d>'],
    \ 'PrtExit()':            ['<esc>', '<c-c>'],
    \ }

let g:ctrlp_working_path_mode = 'ca'

" }}}2

" markdown (@gabrielelana, @ibabushkin)
let g:markdown_enable_mappings = 0

" Figlet
let g:figletFontDir='/usr/share/figlet/fonts'
let g:figletFont='slant'


" tagbar
" let g:tagbar_type_help = {
"     \ 'ctagstype' : 'help',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
"     \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'
" \ }

" http://stackoverflow.com/questions/26145505/using-vims-tagbar-plugin-for-latex-files
" \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'

" recent ctags development versions support latex under tex
" TODO: why are subsections not working?
" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'tex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'u:subsections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
" \ }

" Syntastic

" let g:syntastic_enable_perl_checker = 1
" function! EnablePerlCheck()
" endfunction
" autocmd FileType perl noremap <buffer> <Leader>s :<C-U>call EnablePerlCheck()<CR> 

" echo g:loaded_syntastic_plugin
" echo g:loaded_syntastic_util_autoload
" echo &runtimepath

" chktex is a bit too noisy
let g:syntastic_tex_checkers = ['lacheck']  " , 'chktex']
let g:syntastic_vim_checkers = ['vint']

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 4

let g:syntastic_mode_map = {
    \ "mode" : "passive",
    \ }

"    \ "passive_filetypes" : [ "matlab" ] }

" latex-to-unicode provided by the julia plugin
" let g:latex_to_unicode_file_types = ".*" = ["tex"]
let g:latex_to_unicode_auto = 1
let g:latex_to_unicode_eager = 1

" tpope's commentary
let g:commentary_map_backslash = 0

" makeshift
" consider writing my own, makeshift uses set makeprg not :compiler
" let g:makeshift_systems = {
"     \   'latexmkrc': 'latexmk',
"     \}

let g:secure_modelines_allowed_items = [
    \ "textwidth",   "tw",
    \ "softtabstop", "sts",
    \ "tabstop",     "ts",
    \ "shiftwidth",  "sw",
    \ ]

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                                                      __
"      _________  ____ ___  ____ ___  ____ _____  ____/ /____
"     / ___/ __ \/ __ `__ \/ __ `__ \/ __ `/ __ \/ __  / ___/
"    / /__/ /_/ / / / / / / / / / / / /_/ / / / / /_/ (__  )
"    \___/\____/_/ /_/ /_/_/ /_/ /_/\__,_/_/ /_/\__,_/____/
"
" ────────────────────────────────────────────────────────────────────────
" commands {{{1

" source our .vimrc
command! ReloadVimrc :source $MYVIMRC


" check for a shebang line and set up to execute
function! SetShebangRun()
    if executable(expand('%:p')) && getline(1) =~# '^#!'
        nnoremap <silent> <buffer> <leader><bslash>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
        nnoremap <silent> <buffer> <F5>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
    endif
endfunction

" displays a list of figlet fonts
function! s:FigPickerMode()
    let figfontwinnr = bufwinnr('__Figpicker__')
    if figfontwinnr != -1
        execute figfontwinnr . 'wincmd w'
        silent execute ':0/' . g:figletFont
        return
    end
    execute 'silent keepalt vertical 20 new __Figpicker__'
    let g:figletPickerWindow = winnr()
    setl nonu cursorline nospell 
    setl noreadonly
    setl buftype=nofile bufhidden=hide noswapfile nobuflisted 
    setl nolist nowrap winfixwidth textwidth=0 
    execute ':.!figlist -d ' . g:figletFontDir . '| tail -n +3'
    :g/in this direc/d
    silent execute ':/' . g:figletFont
    try
        nnoremap <silent> <buffer> <esc> :wincmd c<cr>
        nnoremap <silent> <buffer> q :wincmd c<cr>
        nnoremap <silent> <buffer> 
            \ <cr> ^y$:let g:figletFont='<c-r>"'<cr><c-w>p
    endtry
    setl nomodifiable nomodified
endfunction


" toggle syntastic passive mode


command! -nargs=0 FigPick call <sid>FigPickerMode()

function! SyntaxToggle()
    execute 'SyntasticToggleMode'
    if g:syntastic_mode_map['mode'] ==? 'active'
        execute 'SyntasticCheck'
    endif
endfunction

" remove trailing whitespace
command! -range=% Trim <line1>,<line2>s/\s\+$//e
command! ShowTrailingWhitespace /\s\+$/

" put command output into a scratch buffer
" from http://vim.wikia.com/wiki/List_loaded_scripts
function! s:ScratchCmd(command, ...)
   redir => lines
   let saveMore = &more
   set nomore
   execute a:command
   redir END
   let &more = saveMore
   call feedkeys("\<cr>")
   new | setlocal buftype=nofile bufhidden=hide noswapfile
   put=lines
   if a:0 > 0
      execute 'vglobal/'.a:1.'/delete'
   endif
   if a:command == 'scriptnames'
      %substitute#^[[:space:]]*[[:digit:]]\+:[[:space:]]*##e
   endif
   silent %substitute/\%^\_s*\n\|\_s*\%$
   let height = line('$') + 3
   execute 'normal! z'.height."\<cr>"
   0
endfunction

command! -nargs=? Scriptnames call <sid>ScratchCmd('scriptnames', <f-args>)
command! -nargs=+ ScratchCommand call <sid>ScratchCmd(<f-args>)



" helper for control P to open file in preview window
function! PreviewFile(action, line)
    if a:action =~ '^e$'  
        let filename = fnameescape(fnamemodify(a:line, ':p'))
        call ctrlp#exit()
        exec 'pedit' . filename
        wincmd P 
    else
        " Use CtrlP's default file opening function
        call call('ctrlp#acceptfile', [a:action, a:line])
    endif
endfunction

" open to file under cursor with CtrlP
function! CtrlPCursorFile()
    let fname = expand("<cfile>")
    if empty(fname)
        echohl ErrorMsg
        echo "No file name under cursor"
        return
    endif

    let l:olddefault = 0
    if exists("g:ctrlp_default_input")
        let l:olddefault = g:ctrlp_default_input
    endif
    let g:ctrlp_default_input = fname

    let l:oldopenfunc = {}
    if exists("g:ctrlp_open_func")
        let l:oldopenfunc = g:ctrlp_open_func
    endif
    let g:ctrlp_open_func = { 'files' : 'PreviewFile' }

    " maybe use mixed mode instead: 0 -> ctrlp#mixed#id()?
    call ctrlp#init(0, { 'mode': 'r' })

    let g:ctrlp_default_input = l:olddefault
    let g:ctrlp_open_func = l:oldopenfunc
endfunction

" sling to tmux operator
let g:slimux_tmux_path = '/usr/bin/tmux'
function! SlingOper(type)
    if !exists("b:code_packet")
        let b:code_packet = { "target_pane": "", "type": "code" }
    endif
    let rv = getreg('"')
    let rt = getregtype('"')
    sil exe "'[,']yank"
    call SlimuxSendCode(@")
    call setreg('"',rv, rt)
endfunction

" returns a list of buffers
function! GetBufferList()
    redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction

" toggle either the quickfix or location windows 
function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 
            \ 'v:val =~ "'.a:bufname.'"'), 
            \ 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1
            exec(a:pfx.'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location List is Empty."
        return
    endif
    let winnr = winnr()
    exec(a:pfx.'open 8')
    if winnr() != winnr
        " wincmd p
    endif
endfunction



command! Bind windo setl scrollbind | setl cursorbind | setl cursorline


set foldmethod=marker
set foldlevel=0
set foldcolumn=0
set foldtext=FoldText()

function! FoldText()
    let l:fs = nextnonblank(v:foldstart)
    if l:fs > v:foldend
        let l:line = getline(v:foldstart)
    else
        let l:line = substitute(getline(l:fs), '\t',
            \ repeat(' ', &tabstop), 'g')
    endif
    let l:cms = split(substitute(&commentstring, ' ', '', 'g' ), '%s')
    let l:line = substitute(l:line, ''.l:cms[0] . '\s*', '', '')
    let l:line = substitute(l:line, '{\{3}\d\?\s*', '', '')
    let l:line = substitute(l:line, '\s\+$', '', '')

    let l:foldSize = 1 + v:foldend - v:foldstart
    let l:foldSizeStr = l:foldSize . ' lines'
    let l:foldLevelStr = repeat('*', v:foldlevel)
    let l:lineCount = line('$')
    let l:foldPerc = printf('(%.1f%%)', (100.0*l:foldSize)/l:lineCount)
    let l:left = '[ ' . l:line . ' '
    let l:right = ' ' . l:foldSizeStr . ' '
        \ . l:foldLevelStr . ' ' . l:foldPerc . ' ]'
    let l:width = (&textwidth > 0 ? &textwidth : 75)
    let l:expansionString = repeat('·', 
        \ l:width - strwidth(l:left . l:right))
    return l:left . l:expansionString . l:right
endfunction

function TerseOneFoldText()
    let l:line = getline(v:foldstart)
    " let line = substitute( line, '^[^0-9a-zA-Z]*', '', '' )
    let l:com_str = split(substitute(&commentstring, " ", "", "g" ), "%s")
    let line = substitute(l:line, "" . com_str[0] . "\s*", "", "" )
    " if it's a start/end comment
    if len(line) > 1
        let line = substitute( line, "\s*" . com_str[1], "", "" )
    endif
    let l:fmr = split( &foldmarker, "," )
    let line = substitute( line, "\s*"  . fmr[0] . '\d*\s*', '', '' )

    " number of folded lines
    let len  = v:foldend - v:foldstart
    let depth = v:foldlevel
    let depth_str = ">"
    while depth != 1
        let depth = depth - 1
        let depth_str .= ">"
    endwhile
    return  printf("%-5s", depth_str) . printf("%4d", len) . ': ' . line
endfunction

function! TxtFoldText()
  let level = repeat('-', min([v:foldlevel-1,3])) . '+'
  let title = substitute(getline(v:foldstart), '{\{3}\d\?\s*', '', '')
  let title = substitute(title, '^["#! ]\+', '', '')
  " return printf('%-2s %-s', level, title)
  return printf('[%s][%s]', level, title)
endfunction

function! ToggleTextWidth()
    if &l:textwidth > 0
        let s:old_tw = &l:textwidth
        let &l:textwidth = 0
    else
        if exists('s:old_tw')
            let &l:textwidth = s:old_tw 
        else
            let &l:textwidth = 75
        endif
    endif
endfunction

nnoremap <leader>v :call ToggleTextWidth()<cr>

autocmd OptionSet shiftwidth noautocmd 
      \ let &l:tabstop = &l:shiftwidth | let &l:shiftwidth=0

" autocmd BufReadPost * echom string(&shiftwidth).'|'.string(&l:shiftwidth)

" function! Retab(ts)
"     retab!
"     setl noexpandtab
"     let &l:shiftwidth = a:ts 
"     let &l:tabstop = a:ts
"     setl expandtab
" endfunction

function! CompletionChain(findstart, base)
  if a:findstart
    " Test against the functions one by one
    for fcn in g:user_completion_chain
      let pos = call(fcn, [a:findstart, a:base])

      " If a function can complete the prefix,
      " remember the name and return the result from the function
      if pos >= 0
        let s:current_completion = fcn
        return pos
      endif
    endfor

    " No completion can be done
    unlet! s:current_completion
    return -1
  elseif exists('s:current_completion')

    " Simply pass the arguments to the selected function
    return call(s:current_completion, [a:findstart, a:base])
  endif

  return []
endfunction

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                     __
"    _______  _______/ /_____  ____ ___     ____ ___  ____ _____  _____
"   / ___/ / / / ___/ __/ __ \/ __ `__ \   / __ `__ \/ __ `/ __ \/ ___/
"  / /__/ /_/ (__  ) /_/ /_/ / / / / / /  / / / / / / /_/ / /_/ (__  )
"  \___/\__,_/____/\__/\____/_/ /_/ /_/  /_/ /_/ /_/\__,_/ .___/____/
"                                                       /_/
" ────────────────────────────────────────────────────────────────────────
" custom maps {{{1

" clear search highlight
nnoremap <silent> <leader>/  :<C-U>nohls<CR>

" toggle airline
nnoremap <silent> <leader>_  :AirlineToggle<CR>

" latex-to-unicode via the julia plugin
nnoremap <expr> <leader>u LaTeXtoUnicode#Toggle()

" default update and compile button (using vim-dispatch)
nnoremap <silent> <leader><leader>  :<C-U>up<CR>:Make!<CR>
nnoremap <silent> <F5>              :<C-U>up<CR>:Make!<CR>

" if current file is executable and has a hashbang, allow it to run
augroup shebang_run
    autocmd!
    autocmd FileType sh     call SetShebangRun()
    autocmd FileType python call SetShebangRun()
    autocmd FileType perl   call SetShebangRun()
augroup END

" paste mode <silent> xxx
nmap  yp <Plug>unimpairedPastea
nmap  yP <Plug>unimpairedPastei

" enable/disable folding
nnoremap [of :setlocal foldenable<cr>
nnoremap ]of :setlocal nofoldenable<cr>

" latex stuff
" nnoremap <silent> <leader>lx :<C-U>call SetXeTex()<CR>
" nnoremap <silent> <leader>lz :<C-U>call CompileXeTex()<CR>
" noremap <silent> <leader>le :<C-U>call OpenLog()<CR>

" change to file's directory, locally or globally
nnoremap <silent> <leader>.  :<C-U>lcd %:p:h<CR>:pwd<CR>
nnoremap <silent> g.         :<C-U>cd %:p:h<CR>:pwd<CR>

" tagbar show and hide
nnoremap <silent> <leader>T  :<C-U>TagbarToggle<CR>

" figlet
nnoremap <silent> gy :set operatorfunc=FigOper<cr>g@
nnoremap <silent> gyy :.Figlet<cr>
vnoremap <silent> gy :Figlet<cr>
nnoremap <silent> gY :call <sid>FigPickerMode()<cr>

" show syntax under cursor
nnoremap gb :call SyntaxAttr()<cr>
nnoremap gB :echo "hi<"
    \ . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
    \ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
    \ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>

" free keys xxx
" gb show syntax
" gc tpope/commentary
" gl
" gy figlet
" gz
" zp
" zu
" zy

" latex
augroup filetype_tex
    autocmd!
    autocmd FileType tex nnoremap <silent> <buffer> <leader><bslash>
        \ :<c-u>up<cr>:VimtexCompile<cr>
    autocmd FileType tex nnoremap <silent> <buffer> <F5>
        \ :<c-u>up<cr>:VimtexCompile<cr>
augroup END







    " shortcuts to evaluate vimscript
    autocmd FileType vim nnoremap <silent> <buffer> <leader><bslash>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>
    autocmd FileType vim nnoremap <silent> <buffer> <F5>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>

    autocmd FileType vim vnoremap <silent> <buffer> <leader><bslash>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>
    autocmd FileType vim vnoremap <silent> <buffer> <F5>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>


" matlab
autocmd FileType matlab setlocal commentstring=%\ %s

" TODO: use makeprg for these?
" xxx
" autocmd FileType tex noremap <silent> <leader>\  :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>
" autocmd FileType tex noremap <silent> <F5>       :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>





















" xxx would have to add this compiler back in since removed in vimtex
" autocmd FileType tex compiler latexmk | setl makeprg=latexmk





" function! PickerMode(fname)
"   set cursorline
"   let b:picker_fname = fnamemodify(a:fname, ':p')
"   nmap <buffer> <cr> :call writefile([getline(".")], b:picker_fname)<cr>:qa!<cr>
" endfunction
" command! -nargs=1 PickerMode :call PickerMode(<q-args>)



" \] slings content to tmux pane
nnoremap <silent> <leader>]   :set opfunc=SlingOper<cr>g@
nnoremap <silent> <leader>]]  :silent SlimuxREPLSendLine<cr>
vnoremap <silent> <leader>]   :SlimuxREPLSendSelection<cr>

autocmd FileType matlab nnoremap <silent> 
    \ <leader>\ :<c-u>w<cr>:execute ":SlimuxShellRun " . expand('%:r')<cr>

" yanks to tmux.  can we make this more vimmy?
nnoremap <silent> <leader>y  :.w !tmux loadb -<CR>
vnoremap <silent> <leader>y  :w<home>silent <end> !tmux loadb -<CR>

" toggle syntastic
nnoremap <silent> <leader>s  :<C-U>SyntasticCheck<CR>
nnoremap <silent> <leader>S  :<C-U>call SyntaxToggle()<CR>

" refresh syntax highlighting
nnoremap <silent> <leader>z :<c-u>syntax sync fromstart<cr>


" set pastetoggle=
" set pastetoggle=<leader>`

" unnecessary keys
inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

" easier movement in command mode
cnoremap <c-h> <left>
cnoremap <c-l> <right>
cnoremap <c-o> <s-right>
cnoremap <c-x> <s-left>

" vdebug
nnoremap <Leader>x :<C-U>VdebugEval 

" quickfix and location lists
nmap <silent> <leader>W :<C-U>call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>Q :<C-U>call ToggleList("Quickfix List", 'c')<CR>

nmap <silent> <leader>w :<C-U>CtrlPLocList<CR>
nmap <silent> <leader>q :<C-U>CtrlPQuickfix<CR>

" general ctrl-p mappings
nmap <silent> <leader>t :<C-U>CtrlPTag<CR>

" xxx these are the same..
nmap <silent> <leader>6 :<C-U>CtrlPBuffer<CR>
nmap <silent> <leader>p :<C-U>CtrlPBuffer<CR>

nnoremap <silent> <leader>[ :<C-U>CtrlPMRUFiles<CR>
nnoremap <silent> <leader>o :<C-U>CtrlP<CR>
nnoremap <leader>O :<C-U>CtrlP 


    " exec 'pedit ' . a:file
    " if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'

    "   " Get the filename
    "   let filename = fnameescape(fnamemodify(a:line, ':p'))

    "   " Close CtrlP
    "   call ctrlp#exit()

    "   " Open the file
    "   silent! execute '!xdg-open' filename

    " elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'

    "   " Not a HTML file, simulate pressing <c-o> again and wait for new input
    "   call feedkeys("\<c-o>")

    " else

    "   " Use CtrlP's default file opening function
    "   call call('ctrlp#acceptfile', [a:action, a:line])

    " endif

nmap <silent> <leader>f :<C-U>call CtrlPCursorFile()<CR>

" open preview window of file under cursor (doesn't always work)
" nmap <silent> <leader>o :<C-U>exec 'pedit ' . expand('<cfile>') <CR><C-W>P
" was <tab> but this conflictrs
"

"" autocmd FileType matlab nnoremap <buffer> <leader>\ :make<CR><CR>
"" autocmd FileType matlab set makeprg=mluxrun\ %:r

" autocmd FileType matlab nnoremap <buffer> K :Mhelp <C-R>=expand('<cword>')<CR><CR>

" increment/decrement
nnoremap <leader>- <c-x>
vnoremap <leader>- <c-x>
vnoremap <leader>g- g<c-x>
nnoremap <leader>= <c-a>
vnoremap <leader>= <c-a>
vnoremap <leader>g= g<c-a>

" ctrl a conflicts with tmux
nnoremap <c-a> <nop>

" go to end of current word and start completion
function! s:EndOfWord()
    if getpos('.')[2] > 1
        normal! h
    endif
    normal! e
endfunction
nmap <silent> <c-x> :call <sid>EndOfWord()<cr>a<f19>

" g:ycm_key_invoke_completion
imap <c-z> <f19>

" }}}1

" final setup
call SiteSetupPost()

set secure

