" ────────────────────────────────────────────────────────────────────────
"      ___              __     _                _
"     /   |  ____  ____/ /_  _( )_____   _   __(_)___ ___  __________
"    / /| | / __ \/ __  / / / /// ___/  | | / / / __ `__ \/ ___/ ___/
"   / ___ |/ / / / /_/ / /_/ / (__  )   | |/ / / / / / / / /  / /__
"  /_/  |_/_/ /_/\__,_/\__, / /____/    |___/_/_/ /_/ /_/_/   \___/
"                     /____/
" ────────────────────────────────────────────────────────────────────────

" overview {{{1
" \\, <f5>,     update and compile document (filetype dependent)
" \=, \-
" \g=, \g-      increment, decrement
" \.            locally change directory
" \/            remove highlight
" \[            CtrlP MRU
" \]{motion},
" \]],
" {Visual}\],   Sling to tmux
" \a
" \b
" \c
" \d            YcmCompleter GoTo (mnemonic: definition)
" \e
" \f            CtrlP to file under cursor
" \g            :Ag prompt
" \G            Ag search for word under cursor
" \h
" \i            YcmDiagnostic (TODO)
" \j
" \J            Join with commas
" \k
" \l            vimtex mappings
" \m            parse modelines
" \n            Narrow region
" \o            CtrlP (all files in directory)
" \p            CtrlP buffers
" \q            CtrlP quickfix
" \Q            Toggle quickfix
" \r            Clipbrd (register view)
" \s            Syntax check
" \S            Syntax toggle
" \t            CtrlP tags
" \T            Toggle tagbar
" \u            Toggle latex-to-unicode
" \v            Toggle textwidth
" \w            CtrlP locations
" \W            Toggle location list
" \x            :VdebugEval prompt (TODO)
" \y            Yank to tmux
" \z            Re-sync syntax highlighting
"
" gy{motion},
" gyy,
" {Visual}gy    figlet
" gY            figlet font picker
" g.            globally change directory
" gb, gB        show syntax under cursor
"                   (also scriptease zS)
" gl            convert :emoji: into emoji
"
" yp, yP        open line and set paste (above, below)
"
" F-maps
" <f2>          ycm detailed diagnostics
" <f7>          vimtex new command
" <f19>         ycm invoke completion
" <f24>/<f25>   focus gained/lost
" <f26>         <s-cr>
"
" free keys: gz zp zy z/ g/ z\ g\
" <f20> to <f37>
" this is really k1-k9,k;,FA-FZ

" Todo
"   - ripgrep
"   - syntastic -> ale
"   - vdebug
"   - completion (mucomplete?)
"   - automatic indent / modelines
"   - supertab chain?
"   - what is setting up bracketed paste?
"   - window management (dwm.vim/goldenview/etc)
"   - map for :Trim
"   - vim-devicons
"   - fmt equalprg vs q
"   - help abbr
"   - look into cycle/switch
"   - better increment/decrement
"   - clipbrd/tregisters
"   - tags gutentags vs highlighting (easytags/taghighlight)
"   - vis.vim?

" }}}1

" the basics {{{1
set ts=4
set sw=4
set textwidth=74
set wm=2
set cc=+1
set expandtab
set bs=indent
set ffs=unix,dos

set noswapfile
set virtualedit=block

set ttimeout ttimeoutlen=10
set mouse=a ttymouse=xterm2

set nu
if !&hlsearch | set hlsearch | endif
set spell spelllang=en_us
set spellsuggest=best,5
set thesaurus=~/.vim/config/mthesaur.txt
" set dictionary=/usr/share/dict/words

" set formatprg=fmt\ --width=&textwidth
" set formatprg=fmt\ --width=74\ -u
" let $PARINIT='rTbgqR B=.,?_A_a Q=_s>|'

" allow formatprg to justify text to the current textwidth
if executable('par')
    function! SetFormatPrg()
        if &textwidth > 0 && (&formatprg =~ 'par' || &formatprg is '')
            let &formatprg='par rTbgqR B=.,\?_A_a Q=_s\>\| '.&textwidth.'j'
        endif
    endfunction
    augroup rc_formatprg
        autocmd!
        autocmd OptionSet textwidth call SetFormatPrg()
    augroup END
    call SetFormatPrg()
endif

" j: remove comments when joining
" l: don't break long lines in insert mode
set formatoptions+=jl

" changes the behavior of <cr> in two ways:
"   - <cr> now accepts an autocomplete
"   - <cr> starts a new undo sequence
"   xxx conflicts with ycm
" inoremap <expr> <CR> pumvisible() ? "\<C-y>" : "\<C-g>u\<CR>"

" set fillchars=vert:║,fold:- ─
set fillchars=stl:\ ,stlnc:\ ,fold:\ ,vert:│
set listchars=tab:»·,eol:↲,nbsp:␣,extends:…
set listchars+=space:␣,precedes:<,extends:>,trail:·
let &showbreak = " ❯❯❯ "   " ∴  ⮱  → ↳ 🡆 ❯

set laststatus=2
set scrolloff=2
set wildmenu wildignorecase
set wildmode=longest:full,full   " list:longest,full
set suffixes+=.pdf,.synctex
set isfname-==

set splitbelow
set splitright
set switchbuf=useopen " ,split
set previewheight=18

set nomodeline modelines=3
set infercase

set nosol

" disable intro
set shortmess+=I

" under ssh, disable clipboard to make things faster
if $SSH_CLIENT != ''
    set clipboard=exclude:.*
endif

" use ag for grepping
if executable('ag')

    function! s:ag_do_qf(title)
        if empty(getqflist())
            cclose
            return
        endif

        let [l:lnum, l:bufnr] = [ line('.'), bufnr('') ]

        " open or jump to quickfix window
        copen

        " get the corresponding quickfix line
        let l:qfln = map(getqflist(), 'v:val.bufnr == '.l:bufnr
                    \ . '&& v:val.lnum == ' .l:lnum )
        let l:qfln = index(l:qfln, 1)+1
        if l:qfln > 0
            " go to line and ensure folds are open
            execute 'normal! '.l:qfln.'ggzv'

            " this naturally jumps back to the previous buffer
            execute 'cc '.l:qfln
        endif

        call setqflist([], 'a', {'title': a:title})
    endfunction

    set grepprg=ag\ --nogroup\ --nocolor\ --smart-case\
        \ --column\ --follow\ -C0\ -W120
    set grepformat=%f:%l:%c:%m

    function! s:ag_do(qargs)
        let l:t_te = &t_te
        let l:t_ti = &t_ti
        set t_te= t_ti=

        exe 'silent! grep!' a:qargs

        let l:ecmd = escape('Ag ' . a:qargs, '#%|')
        call s:ag_do_qf(':'.l:ecmd)
        call histadd('cmd', l:ecmd)

        redraw!

        let &t_te = l:t_te
        let &t_ti = l:t_ti
    endfunction

    " xxx don't switch to alternate terminal (t_ti/t_te)
    " xxx make this a function
    " command! -nargs=+ -complete=file -bar Ag silent! grep! <args>
    "     \ | call histadd('cmd', escape('Ag '.<q-args>, '#%|'))
    "     \ | call s:ag_do_qf(escape(':Ag '.<q-args>, '#%|'))
    "     \ | redraw!

    " command! -nargs=+ -complete=file -bar Ag silent! grep! <args>
    "     \ | redraw!
    
    command! -nargs=+ -complete=file -bar Ag call s:ag_do(<q-args>)

endif

if exists(':Ag')
    function! s:ag_cword()
        return escape(shellescape(expand("<cword>"), 1), '#%|')
    endfunction
    nnoremap <leader>G :Ag -Q <c-r>=<sid>ag_cword()<cr><cr>
    nnoremap <leader>g :Ag<space>
endif

" global rc options
let g:rc_disable_youcompleteme = 1
let g:rc_tmux_cursor_codes = 1
let g:rc_no_colors = 0

" vim global opts
let g:vimsyn_embed = 0  " cf vim/vim/issues/668
let g:tex_flavor='latex'
let g:tex_comment_nospell=1

" directory for the rest of the configuration
let g:config_home = expand('~/.vim/config')
augroup rc_config_home
    au!
    autocmd BufEnter *vimrc exe 'setl path+='.g:config_home
augroup END

" some settings will change if we are inside tmux
let g:within_tmux = ($TMUX != '')

" load site-specific configs
let g:site_config = g:config_home.'/site.'.hostname().'.vim'
if !filereadable(g:site_config)
    let g:site_config = g:config_home.'/site.default.vim'
endif

exe 'source' g:site_config

" load color handling module
exe 'source' g:config_home.'/colors.vim'

" }}}1

" ────────────────────────────────────────────────────────────────────────
"             __            _
"      ____  / /_  ______ _(_)___  _____
"     / __ \/ / / / / __ `/ / __ \/ ___/
"    / /_/ / / /_/ / /_/ / / / / (__  )
"   / .___/_/\__,_/\__, /_/_/ /_/____/
"  /_/            /____/
" ────────────────────────────────────────────────────────────────────────
" plugins {{{1

" install this FileType hook now to set options
" before plugins get a chance to do anything
augroup rc_pre_filetype_plugin
    autocmd!
    autocmd FileType * call s:PreFTPlugin(expand("<amatch>"))
augroup END

" custom modelines should be read at the end of BufEnter (for setting
" readonly) or at the top of BufWinEnter (overloading built-in modeline)
" https://github.com/vim/vim/blob/dde81312/src/buffer.c#L348
"
" the (empirically determined) order is:
" (BufReadPost, FileType, BufEnter, <modeline>, BufWinEnter)
function! s:top_bufwinenter_hook()
endfunction
augroup rc_top_bufwinenter_hook
    autocmd!
    autocmd BufWinEnter * call s:top_bufwinenter_hook()
augroup END

" try to install this as late as possible so
" that it can act similar to setting a modeline
" xxx could we just use after/..?
function! s:buf_stdin_readpost()
    let b:do_end_bufenter_hook = 1
    call s:install_end_bufenter_hook(1)
endfunction
augroup rc_buf_stdin_readpost
    autocmd!
    autocmd BufReadPost,StdinReadPost * call s:buf_stdin_readpost()
augroup END

function! s:mostshift()
    let l:most = []
    if !filereadable(@%) | return [0, []] | endif
    try
        let l:most = split(system("mostshift '".@%."'"), '\_s\+')
    endtry

    let l:sw = 0
    if len(l:most) >= 1
        let l:sw = str2nr(l:most[0])
        let l:flags = split(get(l:most, 1, ''), ',')
    endif
    return [l:sw, l:flags]
endfunction

" note: unlike BufReadPost this is called each time when switching 
" windows, so we use a buffer flag to prevent multiple
function! s:end_bufenter_hook()
    if !get(b:, 'do_end_bufenter_hook', 0) | return | endif
    let b:do_end_bufenter_hook = 0

    if &buftype isnot '' | return | endif

    " use mostshift to determine the number of spaces per indent
    let [l:sw, l:flags] = s:mostshift()

    " file has determinable shiftwidth
    if l:sw > 0
        let &shiftwidth = l:sw
        let &tabstop = l:sw
        if !&et | setl et | endif
    endif

    " file uses a mix of tabs and spaces
    " xxx this is more annoying than useful
    " if index(l:flags, 'space') > -1 && index(l:flags, 'tab') > -1
    "     set tabstop=8
    " endif
endfunction

function! s:install_end_bufenter_hook(enabled)
    augroup rc_end_bufenter_hook
        autocmd!
        if a:enabled
            " xxx should we use nested here?
            autocmd BufEnter * nested call s:end_bufenter_hook()
        endif
    augroup END
endfunction

" specific plugin disable
if get(g:, 'rc_disable_youcompleteme', 0)
    let g:loaded_youcompleteme = 1
endif

" source the plugin list
" usually at ~/.vim/config/plugs.vim
execute 'source' g:config_home.'/plugs.vim'

" if !exists("g:colors_name")
" endif

" colorscheme setup
" set background=dark
" if !$NO_COLORSCRIPT && &term !~ 'putty'
" "   setting shell path is not necessary
" "    let g:base16_shell_path='~/scripts/base16-shell/'
"     let base16colorspace=256
" endif
" colorscheme base16-eighties
" colorscheme nord
" let g:airline_theme = 'nord'

" jump to the last position in file when reopening
augroup rc_last_position
    autocmd!
    autocmd BufReadPost * 
        \ if line("'\"") > 0 && line("'\"") <= line("$")
        \ | exe 'normal! g`"zv' | endif
augroup END

" allows cursor to change
" XXX this can be cleaned up, maybe just use wincent/terminus
" also see jszakmeister/vim-togglecursor
if g:within_tmux
    function! s:tmux_escape(c)
        return "\<Esc>Ptmux;\<Esc>".a:c."\<Esc>\\"
    endfunction
    if g:rc_tmux_cursor_codes
        " this requires tmux codes to be set appropriately
        let &t_SI = "\<Esc>[6 q"
        let &t_EI = "\<Esc>[2 q"
        let &t_SR = "\<Esc>[4 q"
    else
        let &t_SI = s:tmux_escape("\<Esc>]50;CursorShape=1\x7")
        let &t_EI = s:tmux_escape("\<Esc>]50;CursorShape=0\x7")
        let &t_SR = s:tmux_escape("\<Esc>]50;CursorShape=2\x7")
    endif
else
         " let l:color = '292D3E'
    "     let l:code = "\<Esc>]11;#".l:color."\x7"
    "     sil! exe "!echo ".shellescape(l:code,1)
    "     sil! redraw!

    function! KonsoleBgSet()
        let l:color = '#292D3E'
        " let l:color = 'red'
        return '\e]11;'.l:color.'\a'
    endfunction
    function! KonsoleDoSetBg()
        let l:t_te = &t_te
        let l:t_ti = &t_ti
        set t_te= t_ti=
        exe "sil! !echo -ne ".shellescape(KonsoleBgSet(),1)
        let &t_te = l:t_te
        let &t_ti = l:t_ti
    endfunction

    " sil! redraw!
    " au InsertEnter,InsertLeave * call KonsoleDoSetBg()

    " let &t_ts = s:KonsoleBgSet() . ''

    function! s:KonsoleProfile(s)
        return "\<Esc>]50;".a:s."\x7"
    endfunction
    let &t_SI = s:KonsoleProfile('CursorShape=1;BlinkingCursorEnabled=1')
    let &t_EI = s:KonsoleProfile('CursorShape=0;BlinkingCursorEnabled=0')
    let &t_SR = s:KonsoleProfile('CursorShape=2;BlinkingCursorEnabled=1')
endif




" transparent background
if !has("gui_running")
    hi Normal ctermbg=none
end

" }}}1

" ────────────────────────────────────────────────────────────────────────
"             __            _                      __  _
"      ____  / /_  ______ _(_)___     ____  ____  / /_(_)___  ____  _____
"     / __ \/ / / / / __ `/ / __ \   / __ \/ __ \/ __/ / __ \/ __ \/ ___/
"    / /_/ / / /_/ / /_/ / / / / /  / /_/ / /_/ / /_/ / /_/ / / / (__  )
"   / .___/_/\__,_/\__, /_/_/ /_/   \____/ .___/\__/_/\____/_/ /_/____/
"  /_/            /____/                /_/
" ────────────────────────────────────────────────────────────────────────
" plugin options {{{1

" clipbrd {{{2
"
let g:no_clipbrd_maps = 1

" }}}2

" narrow region {{{2

let g:nrrw_rgn_nomap_nr = 1
let g:nrrw_rgn_nomap_Nr = 1

xmap <leader>n <Plug>NrrwrgnDo
nmap <silent> <leader>n <Plug>NrrwrgnDo

" }}} 2

" scratch {{{2

let g:scratch_autohide = 1

" }}}2

" unicode {{{2

" (this is a typo in the plugin)
nmap <sid>(unicode_un0) <plug>(UnicodeSwapCompleteName))
nmap <sid>(unicode_un) <plug>(UnicodeSwapCompleteName)

" }}}2

" unicoder {{{2

let g:unicoder_cancel_normal = 1
let g:unicoder_cancel_insert = 1
let g:unicoder_cancel_visual = 1
let g:unicoder_no_map = 1

" XXX todo
" nnoremap <C-l> :call unicoder#start(0)<CR>
" inoremap <C-l> <Esc>:call unicoder#start(1)<CR>
" vnoremap <C-l> :<C-u>call unicoder#selection()<CR>

" }}}2

" ultisnips {{{2
let g:UltiSnipsSnippetDirectories=["ultisnips"]
let g:UltiSnipsExpandTrigger='<c-z>'  " '<sid>(snipexpand)'
let g:UltiSnipsListSnippets='<sid>(sniplist)'
let g:UltiSnipsJumpForwardTrigger='<c-f>'
let g:UltiSnipsJumpBackwardTrigger='<c-b>'
" let g:UltiSnipsJumpForwardTrigger='<c-j>'  
" let g:UltiSnipsJumpBackwardTrigger='<c-k>'



" TODO XXX
function! UltiSnipsShim()
   call UltiSnips#ExpandSnippetOrJump()
   if get(g:,'ulti_expand_or_jump_res',0)
      return ''
   else
      return 'hello'
   endif
endfunction
" inoremap <c-]> <c-r>=UltiSnipsShim()<cr>

" let g:UltiSnipsListSnippets

" let g:vimtex_imaps_snippet_engine = 'ultisnips'
    " \ 'leader' : 0, 
 
" }}}2

" vimtex {{{2

" autocmd FileType tex :iabbr <buffer> ... \dots

let g:vimtex_view_forward_search_on_start = 0
let g:vimtex_imaps_leader = '`'
let g:vimtex_indent_ignored_envs = ['document', 'aligned']

" cleanup vimtex viewer windows
" function VimtexCleanViewers()
"     if !executable('xdotool') | return | endif

"     let l:xwin_id = b:vimtex.viewer.xwin_id
"     if !l:xwin_id | return | endif

"     call system('xdotool windowclose '. l:xwin_id)
" endfunction

function! VimtexCleanViewers()
    if !executable('xdotool') | return | endif

    for l:b in range(1, bufnr('$'))
        let l:vimtex = getbufvar(l:b, 'vimtex')
        if empty(l:vimtex) | continue | endif

        let l:xwin_id = l:vimtex.viewer.xwin_id
        if !l:xwin_id | continue | endif

        call system('xdotool windowclose '. l:xwin_id)
    endfor
endfunction

function! VimtexCloseViewer()
    if !executable('xdotool') | return | endif
    if !exists('b:vimtex') || empty(b:vimtex) | return | endif

    let l:xwin_id = b:vimtex.viewer.xwin_id
    if !l:xwin_id | return | endif

    call system('xdotool windowclose '. l:xwin_id)
endfunction

augroup vimtex_clean_viewers
    autocmd!
    autocmd User VimtexEventQuit call VimtexCloseViewer()
augroup END

" vimtex delims {{{3

let g:vimtex_delim_list = {'mods' : {}, 'delim_tex': {}, 
      \ 'delim_math': {} }

let g:vimtex_delim_list.mods.name = [
      \ ['\left', '\right'],
      \ ['\mleft', '\mright'],
      \ ['\bigl', '\bigr'],
      \ ['\Bigl', '\Bigr'],
      \ ['\biggl', '\biggr'],
      \ ['\Biggl', '\Biggr'],
      \]
let g:vimtex_delim_toggle_mod_list = [
      \ ['\bigl', '\bigr'],
      \ ['\Bigl', '\Bigr'],
      \ ['\biggl', '\biggr'],
      \ ['\Biggl', '\Biggr'],
      \]

let g:vimtex_delim_list.delim_tex.name = [
      \ ['[', ']'],
      \ ['{', '}'],
      \ ['``', "''"],
      \ ['`', "'"],
      \]

let g:vimtex_delim_list.delim_math.name = [
      \ ['(', ')'],             ['\{', '\}'], 
      \ ['\lvert', '\rvert'],   ['\lVert', '\rVert'],
      \ ['\lfloor', '\rfloor'], ['\lceil', '\rceil'],
      \ ['\langle', '\rangle'], ['\ulcorner', '\urcorner'],
      \ ['[', ']'],
      \]
let g:vimtex_delim_list.delim_math.re = [
      \ ['(', ')'],             ['\\{', '\\}'], 
      \ ['\\lvert', '\\rvert'],   ['\\lVert', '\\rVert'],
      \ ['\\lfloor', '\\rfloor'], ['\\lceil', '\\rceil'],
      \ ['\\langle', '\\rangle'], ['\\ulcorner', '\\urcorner'],
      \ ['\\\@<!\[', '\]'],
      \]

" }}}3

let g:vimtex_compiler_latexmk = {
    \   'backend'    : 'jobs',
    \   'background' : 1,
    \   'continuous' : 0, 
    \   'callback'   : 0
    \}

let g:vimtex_view_automatic = 0
let g:vimtex_view_method = 'zathura'
let g:vimtex_quickfix_open_on_warning = 0

let g:vimtex_quickfix_latexlog = {
    \ 'overfull' : 0,
    \ 'underfull' : 0,
    \}

let g:vimtex_format_enabled = 1


" xxx make tex <buffer> only!
" nnoremap <silent> <plug>(vimtex-delim-toggle-modifier-reverse)
"     \ :call vimtex#delim#toggle_modifier(-1)<cr>

" let g:vimtex_latexmk_continuous = 0
" let g:vimtex_latexmk_background = 1
" let g:vimtex_quickfix_ignore_all_warnings = 0
" let g:vimtex_latexmk_build_dir='build'
" function! SetBuildDir()
 "    let g:vimtex_latexmk_build_dir='build'
" endfunction
" augroup vimtex_config
 "    au!
 "    au User VimtexEventInitPost call SetBuildDir()
" augroup END


function! s:latexSurround()
   let b:surround_{char2nr("e")}
     \ = "\\begin{\1environment: \1}\n\t\r\n\\end{\1\1}"
   let b:surround_{char2nr("c")} = "\\\1command: \1{\r}"
endfunction


function! VimtexHelpLookup()
    let l:start = vimtex#complete#omnifunc(1, [])
    let l:cword = expand('<cword>')
    let l:cword = substitute(l:cword, '^\\', '', '')
    let l:candidates = vimtex#complete#omnifunc(0, l:cword.'\>')
    if empty(l:candidates)
        echom 'nothing'
    else
        let l:pkgname = matchlist(l:candidates[0].menu, 
            \ '\v\[cmd:\s+(.+)\]')[1]
        echom l:pkgname
    end
endfunction


" nnoremap K :call VimtexHelpLookup()<cr>


" xxx this is bad, fix
" let g:ycm_semantic_triggers.text = [ 
"     \ 're!:arrow',
"     \ ]

" CompleteDone
" set completefunc=emoji#complete


" augroup vimtex_config
"     au!
"     au User VimtexEventQuit     VimtexClean
"     " au User VimtexEventQuit     call vimtex#compiler#clean(0)
"     au User VimtexEventQuit     echo &filetype | sleep 2
" augroup END


    " au User VimtexEventQuit     echo &filetype | sleep 10
    " au User VimtexEventQuit     echo b:vimtex.tex | exe 'VimtexClean'   | sleep 1 
    " au User VimtexEventInitPost echo b:vimtex.tex | exe 'VimtexCompile' | sleep 1
    " au VimLeavePre * call VimtexCleanViewers()
    " au User VimtexEventQuit call VimtexCleanViewers()
    " au User VimtexEventQuit echo 'vimtex quitting '.b:vimtex.tex | sleep 400m

" }}}2

" call vimtex#imaps#add_map({
"     \ 'lhs' : 'test',
"     \ 'rhs' : '\tested',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})
"

" control space
" let g:vimtex_imaps_leader = "<c-@>

" call vimtex#imaps#add_map({
"     \ 'lhs' : '{',
"     \ 'rhs' : '{}',
"     \ 'wrapper' : 'vimtex#imaps#wrap_trivial'
" \})

" function! vimtex#imaps#wrap_math(lhs, rhs) " 
"       return s:is_math() ? a:rhs : a:lhs
"   endfunction

"" %! TeX program=XeLaTeX
" function! DetectTexProgram()

"   let l:pat = '^\c\s*%\s*!\?\s*tex\s\+\(TS-\)\?program\s*=\s*\zs.*\ze\s*$'
"   let l:engine_list = {
"       \ 'pdflatex'         : '',
"       \ 'lualatex'         : '-lualatex',
"       \ 'xelatex'          : '-xelatex',
"       \ 'context (luatex)' : '-pdflatex=context',
"       \ 'context (pdftex)' : '-pdflatex=''texexec --xtx''',
"       \ 'context (xetex)'  : '-pdflatex=texexec',
"       \  }

"       " \ 'pdftex'           : 'pdftex',
"       " \ 'luatex'           : 'luatex',
"       " \ 'xetex'            : 'xetex',

"   for l:line in getline(1, 5)
"     let l:engine = matchstr(l:line, l:pat)
"     if len(l:engine) > 0
"       if has_key(l:engine_list, tolower(l:engine)) > 0
"         let l:opt = ' '.l:engine_list[tolower(l:engine)].' '
"         let g:vimtex_latexmk_options .= l:opt
"       else
"         echoerr 'Unknown engine '.l:engine
"       endif
"     endif
"   endfor

" endfunction

" autocmd FileType tex call DetectTexProgram()


" if has("autocmd") && exists("+omnifunc")
"     autocmd Filetype *
"         \   if &omnifunc == "" |
"         \       setlocal omnifunc=syntaxcomplete#Complete |
"         \   endif
" endif



" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=MyComplete |
"     \   endif

function! EmojiComplete(findstart, base)
    let l:omni = emoji#complete(a:findstart, a:base)
    return l:omni

    " if a:findstart
    "     if l:omni < 0
    "         return -1
    "     endif
    "     return l:omni+1
    " endif
    " return l:omni

    " echo 'findstart' a:findstart 'base' a:base '-> omni' l:omni
    " sleep 1
    " echo emoji#complete(a:findstart, a:base)
    " sleep 2
endfunction

" let g:ycm_seed_identifiers_with_syntax = 1
" let g:ycm_collect_identifiers_from_tags_files = 1


" autocmd Filetype *
"     \   if &omnifunc == "" |
"     \       setlocal omnifunc=EmoComplete |
"     \   endif

" SuperTab?
" if &omnifunc == ""
    " setlocal omnifunc=MyComplete
    " setlocal omnifunc=emoji#complete
" endif

" autocmd Filetype * if &omnifunc == "" 
"     \ |     setlocal omnifunc=syntaxcomplete#Complete
"     \ | endif


call SiteSetupAppearance()

" for f in glob(g:config_home.'/site.'.hostname().'.vim', 1, 1)
"     exec 'source' f
" endfor

" airline {{{2
let g:airline_mode_map = {
      \ '__' : '-',
      \ 'n'  : 'N',
      \ 'i'  : 'I',
      \ 'R'  : 'REPLACE',
      \ 'v'  : 'V',
      \ 'V'  : 'V-LINE',
      \ 'c'  : ':',
      \ '' : 'V-BLOCK',
      \ }

let g:airline_left_sep = ''
let g:airline_right_sep = ''
let g:airline_left_alt_sep = ''
let g:airline_right_alt_sep = ''

if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif
let g:airline_symbols.branch = ''
let g:airline_symbols.readonly = '🔒'   " 
let g:airline_symbols.linenr = '≡' " ♫'
let g:airline_symbols.paste = '🐧'   	" hhp
let g:airline_symbols.spell = 'S'   " 📝'
let g:airline_symbols.whitespace = 'w'

let g:airline_symbols.notexists = '*'
let g:airline_symbols.maxlinenr = ''

" let g:airline_symbols.modified = 'm'
" let g:airline_symbols.modified = ' 💡'
" let g:airline_symbols.space = '~'
" let g:airline_symbols.crypt = "\xf0\x9f\x94\x92"



let g:airline#extensions#whitespace#enabled = 0
let g:airline#extensions#bufferline#enabled = 0
let g:airline#extensions#syntastic#enabled = 1
" let g:airline#extensions#tagbar#enabled = 1
let g:airline#extensions#tagbar#enabled = 0
" let g:airline#extensions#branch#enabled = 0

let g:airline#parts#ffenc#skip_expected_string='utf-8[unix]'

let g:airline#extensions#hunks#enabled = 0

" narrow region integration is too ugly
let g:airline#extensions#nrrwrgn#enabled = 0

" xxx
" let g:airline#extensions#tagbar#flags = 'p'

let g:airline#extensions#vimtex#enabled = 0
let g:airline#extensions#vimtex#left = "("
let g:airline#extensions#vimtex#right = ")"

 " let g:airline_extensions = []

let g:airline_section_error = ''  " temporary, to hide red arrow
let g:airline_section_warning = ''

" XXX keep this on because it screws up quickfix airline
" alternatively, play with qf sections to fix
let g:airline_skip_empty_sections = 0

let g:airline_detect_spelllang = 0

" let spc = g:airline_symbols.space
" let g:airline_section_z = airline#section#create(['windowswap', 'obsession', '%3p%%'.spc, 'linenr', 'maxlinenr', spc.':%3v'])

" let g:airline_section_y = 
"             \ '%{airline#util#prepend(airline#parts#ffenc(),0)}'
"             \ . '%{airline#util#wrap("✦".winnr().".".bufnr("%"),10)}'
"

function! WindowNumber(...)
    let builder = a:1
    let context = a:2
    echo builder | sleep 1
    call builder.add_section('airline_b', '%{tabpagewinnr(tabpagenr())}')
    return 0
endfunction
" call airline#add_statusline_func('WindowNumber')
" call airline#add_inactive_statusline_func('WindowNumber')

function! ThisWay()
    return '✦'.winnr().'.'.bufnr("%").' '
endfunction
call airline#parts#define_function('thisway', 'ThisWay')

function! GetFooText()
    return 'hello'
endfunction
call airline#parts#define_function('foo', 'GetFooText')
" call airline#parts#define_minwidth('ffenc', 100)
call airline#parts#define_minwidth('foo', 50)
" let g:airline_section_y = airline#section#create_right(['ffenc', 'foo'])

" let g:airline_section_z = airline#section#create(['windowswap', '%3p%% ', 'linenr', 'maxlinenr', ' :%3v'])



function! GutentagsStatus()
    let l:sl = gutentags#statusline('🔖')
    if strlen(l:sl)
        return substitute(l:sl, '\[ctags]', '', '').' '
    endif
    return ''
endfunction
call airline#parts#define_function('gutentags', 'GutentagsStatus')

" XXX
let g:airline#extensions#windowswap#enabled = 1
let g:airline#extensions#windowswap#indicator_text = '👌' " 🍔 WS'

au User AirlineAfterInit let g:airline_section_z
    \ = airline#section#create( ['windowswap', 'gutentags', 'thisway', 
    \ 'linenr', 'maxlinenr', ' :%3v'] )

" let g:airline_section_z = airline#section#create(
"     \ ['windowswap', 'gutentags', 'thisway', 
"     \  'linenr', 'maxlinenr', ' :%3v'])

" let g:airline_section_z = airline#section#create(
"         \ ['windowswap', 'obsession', '%3p%% ', 'linenr', 'maxlinenr', ' :%3v'])

" let g:airline_section_z = airline#section#create(
"         \ ['windowswap'])

let g:airline#extensions#default#section_truncate_width = {
   \ 'b': 75, 'x': 110, 'y': 88, 'z': 50, 
   \ 'warning': 80, 'error': 80, }

if 0


function! _ShortenDir()
    return substitute(fnamemodify(getcwd(),':~:.'),'\~/Dropbox','DB','')
endfunction

let g:airline_section_b = "%<%{_ShortenDir()}/"
let g:airline_section_x = '%{airline#extensions#tagbar#currenttag()}' 
let g:airline_section_y = '%{airline#parts#filetype()}'
let g:airline_section_z = '%p%% %#__accent_bold#%l%#__restore__#:%2v'
" let g:airline_section_warning = ''
" let g:airline_section_gutter = ''

" let g:airline#extensions#default#section_truncate_width = {
"   \ 'b': 79, 'x': 60, 'y': 60, 'z': 45 }

" there is a base16_eighties theme but it maps normal mode to green
" see https://github.com/vim-airline/vim-airline/issues/1067
"" let g:airline_theme = 'base16'

endif


" }}}2

" gutentags {{{2
let g:gutentags_project_root = [ 'latexmkrc' ]
let g:gutentags_generate_on_missing = 0
let g:gutentags_generate_on_new = 0
let g:gutentags_generate_on_write = 1
let g:gutentags_cache_dir = $HOME.'/.cache/gutentags'

" let g:gutentags_ctags_tagfile
" let g:gutentags_project_root = ['tags'] 
" let g:gutentags_add_default_project_roots = 0
"}}}2

" minimap {{{2

let g:minimap_show='<leader>as'
let g:minimap_update='<leader>au'
let g:minimap_close='<leader>ac'
let g:minimap_toggle='<leader>at'

" }}}2

" netrw/vim-vinegar {{{2
let g:netrw_list_hide = '\(^\|\s\s\)\zs\.\S\+'
let g:netrw_altv = 1
"}}}2

" quickscope {{{2
let g:qs_highlight_on_keys = ['f', 'F', 't', 'T']

let g:qs_second_occurrence_highlight_color_gui = '#f4e541'
let g:qs_first_occurrence_highlight_color_gui = '#41f468'

"}}}2

" viewdoc {{{2
" XXX
let g:viewdoc_open = 'topleft new'
" let g:ViewDoc_tex = 'ViewDoc_help_custom' 
" let g:viewdoc_only = 1

" default to ViewDocHelp!
let g:no_viewdoc_abbrev = 1
let g:no_viewdoc_maps = 1

" cnoreabbrev <expr> h      getcmdtype()==':'
"     \ && getcmdline()=='h'     ? 'ViewDocHelp!' : 'h'
" cnoreabbrev <expr> help   getcmdtype()==':'
"     \ && getcmdline()=='help'  ? 'ViewDocHelp!' : 'help'

" function! s:Help(args)
"         \ :<C-U>exe 'topleft help '.scriptease#helptopic()<CR>
" endfunction
" command! -nargs=* -complete=help Help call <SID>smart_help(<q-args>)
" todo :let @/ =


" XXX leftabove instead
cnoreabbrev <expr> h      getcmdtype()==':'
    \ && getcmdline()=='h'     ? 'topleft help' : 'h'
cnoreabbrev <expr> help   getcmdtype()==':'
    \ && getcmdline()=='help'  ? 'topleft help' : 'help'

"}}}2

let g:Tex_Leader2='<C-\>'

let g:Tex_AutoFolding=0
let g:Tex_ShowErrorContext=0
let g:Imap_FreezeImap=1
let g:Tex_EnvironmentMaps=0
let g:Tex_EnvironmentMenus=0

let g:Tex_DefaultTargetFormat='pdf'
let g:Tex_MultipleCompileFormats='pdf'
" let g:Tex_ViewRule_pdf='zathura -x "gvim+%{line} %{input}"'
" TODO: right now we save this only for tex files
function! SynctexInverseSearch(line, file)
    echo a:file
    " let bufnr = bufnr('^'.a:file.'$')
    " exe bufwinnr.'winc w'
endfunction
" autocmd FileType tex let $VIM_SERVERNAME=v:servername

let g:Tex_ViewRuleComplete_pdf='zathura -x '
    \ . '"vim --servername {v:servername} --remote +\%{line} \%{input}" '
    \ . '$*.pdf 2>/dev/null &'
let g:Tex_ViewRule_pdf='synctex_wrapper'

let g:Tex_CompileRule_pdf='pdflatex -synctex=-1 -interaction=nonstopmode -file-line-error-style $* -max-print-line=255 -shell-escape'
function! SetXeTex()
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
endfunction

function! CompileXeTex()
    let oldCompileRule=g:Tex_CompileRule_pdf
    let g:Tex_CompileRule_pdf='xelatex -interaction=nonstopmode -file-line-error-style $* -max-print-line=255'
    call Tex_RunLaTeX()
    let g:Tex_CompileRule_pdf=oldCompileRule
endfunction

autocmd BufNewFile,BufRead *.tex 
    \ if getline(1) =~? 'xetex\|xelatex' | call SetXeTex() | endif

function! OpenLog()
	let mainfname = Tex_GetMainFileName()
	let mfnlog = fnamemodify(mainfname, ":t:r").'.log'
    execute 'split '.mfnlog
endfunction

" CtrlP {{{2
let g:ctrlp_extensions = [ 'tag', 'quickfix' ]
    " 'tag', 'buffertag', 'quickfix', 'dir', 'rtscript',
    " \ 'undo', 'line', 'changes', 'mixed', 'bookmarkdir']

if executable('ag')
    let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --hidden
          \ --ignore .git
          \ --ignore .svn
          \ --ignore .hg
          \ --ignore .DS_Store
          \ --ignore "**/*.pyc"
          \ --ignore $HOME/.cache
          \ -g ""'
endif

let g:ctrlp_clear_cache_on_exit = 1

let g:ctrlp_map = ''
let g:ctrlp_cmd = 'CtrlPMRUFiles'
let g:ctrlp_prompt_mappings = {
    \ 'PrtClearCache()':      ['<c-g>'],
    \ 'ToggleByFname()':      ['<c-d>'],
    \ 'PrtExit()':            ['<esc>', '<c-c>'],
    \ }

let g:ctrlp_working_path_mode = 'ca'


" call CtrlPGeneric(a_vim_list, 'MyGreatCallback')

" function! MyGreatCallback(selected_value) range
"     echo "You selected: " . a:selected_value
"  endfunction

" }}}2

" Figlet {{{2

let g:figletFontDir='/usr/share/figlet/fonts'
let g:figletFont='slant'

" }}}2

" markdown (@gabrielelana, @ibabushkin) {{{2

let g:markdown_enable_mappings = 0

" }}}2

" vdebug {{{2

let g:vdebug_keymap = {
    \    "run" : "<F13>", 
    \    "run_to_cursor" : "<Leader>R",
    \    "step_over" : "<F2>",
    \    "step_into" : "<F3>",
    \    "step_out" : "<F4>",
    \    "close" : "<Leader>c",
    \    "detach" : "<F7>",
    \    "set_breakpoint" : "<F10>",
    \    "get_context" : "<Leader>w",
    \    "eval_under_cursor" : "<Leader>v",
    \    "eval_visual" : "<Leader>e",
    \}

" }}}2

" youcompleteme {{{2

" ycm + tex: assumes vimtex's omnifunc
if !exists('g:ycm_semantic_triggers')
    let g:ycm_semantic_triggers = {}
endif
let g:ycm_semantic_triggers.tex = [
    \ 're!\\[A-Za-z]*cite[A-Za-z]*(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\[A-Za-z]*ref({[^}]*|range{([^,{}]*(}{)?))',
    \ 're!\\hyperref\[[^]]*',
    \ 're!\\includegraphics\*?(\[[^]]*\]){0,2}{[^}]*',
    \ 're!\\(include(only)?|input){[^}]*',
    \ 're!\\\a*(gls|Gls|GLS)(pl)?\a*(\s*\[[^]]*\]){0,2}\s*\{[^}]*',
    \ 're!\\includepdf(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\includestandalone(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\usepackage(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\documentclass(\s*\[[^]]*\])?\s*\{[^}]*',
    \ 're!\\[A-Za-z]*',
    \ ]

" let g:ycm_min_num_of_chars_for_completion = 99
" let g:ycm_cache_omnifunc = 0

" emoji
let g:ycm_semantic_triggers.text = [
    \ 're!:[A-Za-z]*',
    \ ]

let g:ycm_key_invoke_completion = '<f19>'

let g:ycm_key_detailed_diagnostics = '<f2>'

let g:ycm_show_diagnostics_ui = 0

let g:ycm_global_ycm_extra_conf = '~/.vim/.ycm_extra_conf.py'

let g:ycm_autoclose_preview_window_after_completion = 1

let g:ycm_filetype_blacklist = {
    \ 'tagbar'   : 1,
    \ 'qf'       : 1,
    \ 'notes'    : 1,
    \ 'markdown' : 1,
    \ 'unite'    : 1,
    \ 'vimwiki'  : 1,
    \ 'pandoc'   : 1,
    \ 'infolog'  : 1,
    \ 'mail'     : 1,
    \ 'netrw'    : 1,
    \ 'css'      : 1,
    \ }

" }}}2

" tagbar
" let g:tagbar_type_help = {
"     \ 'ctagstype' : 'help',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
"     \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'
" \ }

" http://stackoverflow.com/questions/26145505/using-vims-tagbar-plugin-for-latex-files
" \ 'deffile' : expand('<sfile>:p:h:h') . '/ctags/latex.cnf'

" recent ctags development versions support latex under tex
" TODO: why are subsections not working?
" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'tex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'u:subsections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort'    : 0
" \ }

" Syntastic

" let g:syntastic_enable_perl_checker = 1
" function! EnablePerlCheck()
" endfunction
" autocmd FileType perl noremap <buffer> <Leader>s :<C-U>call EnablePerlCheck()<CR> 

" echo g:loaded_syntastic_plugin
" echo g:loaded_syntastic_util_autoload
" echo &runtimepath

" tpope's commentary {{{2
let g:commentary_map_backslash = 0
" }}}2

" latex-to-unicode provided by the julia plugin {{{2
" let g:latex_to_unicode_file_types = ".*" = ["tex"]
let g:latex_to_unicode_auto = 1
let g:latex_to_unicode_eager = 1

" }}}2

" syntastic {{{2

" chktex is a bit too noisy
let g:syntastic_tex_checkers = ['lacheck']  " , 'chktex']
let g:syntastic_vim_checkers = ['vint']

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_auto_loc_list = 1
let g:syntastic_loc_list_height = 4

let g:syntastic_mode_map = {
    \ "mode" : "passive",
    \ }

" XXX get mlint working
"    \ "passive_filetypes" : [ "matlab" ] }

" }}}2

" makeshift {{{2

" consider writing my own, makeshift uses set makeprg not :compiler
" let g:makeshift_systems = {
"     \   'latexmkrc': 'latexmk',
"     \}

" }}}2

" XXX annoying mapping
" map <unique> <Leader>hlt <Plug>HiLinkTrace

let g:secure_modelines_allowed_items = [
    \ "textwidth",   "tw",
    \ "softtabstop", "sts",
    \ "tabstop",     "ts",
    \ "shiftwidth",  "sw",
    \ ]

function! FixSwTs()
    " echo 'FixSwTs' &shiftwidth
    " if &shiftwidth > 0
    "     let &tabstop = &shiftwidth
    "     let &shiftwidth=0
    " endif
    " XXX
    echo 'fixswts'
    let &tabstop = &shiftwidth
endfunction


" shiftwidth tabstop softtabstop smarttab expandtab
" preserveindent?

" au BufRead * echo 'BufRead '.&shiftwidth | sleep 1
" au BufEnter * call FixSwTs()

" au BufRead * call FixSwTs()
" au BufEnter * call FixSwTs()

" need to use BufEnter or BufReadEnter for overrides


" }}}1

" ────────────────────────────────────────────────────────────────────────
"                                __     __  _
"    _________  ____ ___  ____  / /__  / /_(_)___  ____
"   / ___/ __ \/ __ `__ \/ __ \/ / _ \/ __/ / __ \/ __ \
"  / /__/ /_/ / / / / / / /_/ / /  __/ /_/ / /_/ / / / /
"  \___/\____/_/ /_/ /_/ .___/_/\___/\__/_/\____/_/ /_/
"                     /_/
" ────────────────────────────────────────────────────────────────────────
" completion {{{1

" notes
"   I use youcompleteme, so only the omnifunc is relevant


" defines a sequence of completion fall-backs
let g:user_completion_chain = [
     \ 'emoji#complete', 
     \ 'syntaxcomplete#Complete',
     \ ]

function! CompletionChain(findstart, base)
  if a:findstart
    " Test against the functions one by one
    for fcn in g:user_completion_chain
      let pos = call(fcn, [a:findstart, a:base])

      " If a function can complete the prefix,
      " remember the name and return the result from the function
      if pos >= 0
        let s:current_completion = fcn
        return pos
      endif
    endfor

    " No completion can be done
    unlet! s:current_completion
    return -1
  elseif exists('s:current_completion')

    " Simply pass the arguments to the selected function
    return call(s:current_completion, [a:findstart, a:base])
  endif

  return []
endfunction

" this is called after the ftplugin, so iff the file type plugin
" provides no file type-specific omnifunc, use the custom chain
function! s:set_omni_completion(ft)
    if &omnifunc == "" 
        setlocal omnifunc=CompletionChain
    endif
endfunction
autocmd FileType * call s:set_omni_completion(expand("<amatch>")) 

" this is called before the ftplugin, so we can set the ycm 
" triggers just in time...
" xxx this doesnt work at all..
function! s:set_ycm_triggers(ft)
    " emoji trigger
    " if !get(g:ycm_semantic_triggers, a:ft, []) 
        " let g:ycm_semantic_triggers[a:ft] = [
        "         \ 're!:[A-Za-z]+',
        "         \ ]
    " endif
endfunction

let s:emoji_filetypes = [ 'vim', 'text', 'markdown' ]
for s:ft in s:emoji_filetypes
    let g:ycm_semantic_triggers[s:ft] = [
        \ 're!:[A-Za-z]+',
        \ ]
endfor

" au CompleteDone * echo

" TODO: enable auto expansion
" using ycm/vim's autocommands

" autocmd User PreFileType_ALL call s:set_ycm_triggers(expand("<amatch>"))

" allow page-up/page-down in the completion menu (XXX needs testing)
inoremap <silent> <expr> <c-u> pumvisible() ? "\<pageup>"   : "\<c-u>"
inoremap <silent> <expr> <c-d> pumvisible() ? "\<pagedown>" : "\<c-d>"


" explicit completion is performed with ctrl-L


" TODO expansion patterns

" insert-mode expansion is performed with ctrl-]
" mnemonic: ending ]
let g:user_expansion_chain = [
         \ 's:ExpandSnippet', 
         \ 's:ExpandEmoji', 
         \ 's:ExpandFallback',
         \ ]

function! s:ExpandSnippet()
   call UltiSnips#ExpandSnippetOrJump()
   if get(g:,'ulti_expand_or_jump_res',0)
      return 1
   else
      return 0
   endif
endfunction

function! s:ExpandEmoji()
   return EmojiReplace()
endfunction

function! s:ExpandFallback()
   call feedkeys("\<F19>")
   return 1
endfunction

function! s:DoExpansion()
   for l:fcn in g:user_expansion_chain
      let l:ret = call(l:fcn, [])
      if l:ret isnot 0
         let s:current_expansion = fcn
         return ''
      endif
   endfor
   return ''
endfunction

" normal available: Ctrl-@ Ctrl-X Ctrl-K Ctrl-\ Ctrl-_ 
" insert available: Ctrl-L Ctrl-G. Ctrl-Z Ctrl-/ Ctrl-B... Ctrl-F Ctrl-]...

" <c-r> instead of <expr> because we may modify the buffer
imap <sid>(expansion) <c-r>=<sid>DoExpansion()<cr>

" <c-r>=UltiSnipsShim()<cr>
imap <c-]> <sid>(expansion)

" function! FFF()
"    return mode()
" endfunction
" imap <F7> <c-r>=FFF()<cr>

" toggles between virtualedit={all, block}
function! s:virtualedit_all(state)
    if !exists('s:virtual_edit')
        let s:virtual_edit = 'all'
    endif
    let l:toggle = (&virtualedit =~# 'all') != a:state
    if l:toggle
        let [&virtualedit, s:virtual_edit]
                \ = [s:virtual_edit, &virtualedit]
    endif
    echo ':set virtualedit='.&virtualedit
endfunction

" }}}1

" ────────────────────────────────────────────────────────────────────────
"      ____                 __  _
"     / __/_  ______  _____/ /_(_)___  ____  _____
"    / /_/ / / / __ \/ ___/ __/ / __ \/ __ \/ ___/
"   / __/ /_/ / / / / /__/ /_/ / /_/ / / / (__  )
"  /_/  \__,_/_/ /_/\___/\__/_/\____/_/ /_/____/
"
" ────────────────────────────────────────────────────────────────────────
" functions {{{1

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                                                    __
"    _________  ____ ___  ____ ___  ____ _____  ____/ /____
"   / ___/ __ \/ __ `__ \/ __ `__ \/ __ `/ __ \/ __  / ___/
"  / /__/ /_/ / / / / / / / / / / / /_/ / / / / /_/ (__  )
"  \___/\____/_/ /_/ /_/_/ /_/ /_/\__,_/_/ /_/\__,_/____/
"
" ────────────────────────────────────────────────────────────────────────
" commands {{{1

" holding shift too long
command! Q quit

" source our .vimrc
command! ReloadVimrc source $MYVIMRC | redraw | echo $MYVIMRC.' reloaded'

" check for a shebang line and set up to execute
function! SetShebangRun()
    if executable(expand('%:p')) && getline(1) =~# '^#!'
        nnoremap <silent><buffer> <leader><bslash>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
        nnoremap <silent><buffer> <F5>
            \ :<C-U>up<CR>:execute "!" . expand("%:p:S")<CR>
    endif
endfunction

" displays a list of figlet fonts
function! s:FigPickerMode() range
    " echo 'range = ' . a:firstline . ',' . a:lastline
    " let l:orig_text = @"

    let figfontwinnr = bufwinnr('__Figpicker__')
    if figfontwinnr != -1
        execute figfontwinnr . 'wincmd w'
        silent execute ':0/' . g:figletFont
        return
    end
    execute 'silent keepalt vertical 20 new __Figpicker__'
    let g:figletPickerWindow = winnr()
    setl nonu cursorline nospell 
    setl noreadonly       " or bufhidden=delete?
    setl buftype=nofile bufhidden=hide noswapfile nobuflisted 
    setl nolist nowrap winfixwidth textwidth=0 
    execute ':.!figlist -d ' . g:figletFontDir . '| tail -n +3'
    :g/in this direc/d
    silent execute ':/' . g:figletFont
    try
        nnoremap <silent> <buffer> <esc> :<c-u>bd<cr>
        nnoremap <silent> <buffer> q :<c-u>bd<cr>
        nnoremap <silent> <buffer> 
            \ <cr> ^y$:let g:figletFont='<c-r>"'<cr><c-w>p
        " nnoremap <buffer>
        "     \ <space> :let g:figletFont='<c-r>=getline('.')<cr>'<cr><c-w>p:Figlet
        nnoremap <buffer> <space>
            \ :let g:figletFont='<c-r>=getline('.')<cr>'<cr>
    endtry
    setl nomodifiable nomodified
endfunction

command! -range -nargs=0 FigPick <line1>,<line2>call <sid>FigPickerMode()

" toggle syntastic passive mode
function! SyntaxToggle()
    execute 'SyntasticToggleMode'
    if g:syntastic_mode_map['mode'] ==? 'active'
        execute 'SyntasticCheck'
    endif
endfunction

" remove trailing whitespace
command! -range=% Trim <line1>,<line2>s/\s\+$//e
command! ShowTrailingWhitespace /\s\+$/

" put command output into a scratch buffer
" from http://vim.wikia.com/wiki/List_loaded_scripts
function! s:ScratchCmd(command, ...)
   redir => lines
   let saveMore = &more
   set nomore
   execute a:command
   redir END
   let &more = saveMore
   call feedkeys("\<cr>")
   new | setlocal buftype=nofile bufhidden=hide noswapfile
   put=lines
   if a:0 > 0
      execute 'vglobal/'.a:1.'/delete'
   endif
   if a:command == 'scriptnames'
      %substitute#^[[:space:]]*[[:digit:]]\+:[[:space:]]*##e
   endif
   silent %substitute/\%^\_s*\n\|\_s*\%$
   let height = min([line('$') + 3, 10])
   execute 'normal! z'.height."\<cr>"
   0
endfunction

command! -nargs=? ScriptnamesBuffer silent call <sid>ScratchCmd('scriptnames', <f-args>)
command! -nargs=+ ScratchCommand silent call <sid>ScratchCmd(<q-args>)

command! -nargs=? Registers silent exe 'ScratchCommand registers '.<q-args>

" function! vimtex#util#command(cmd)
"   let l:a = @a
"   try
"     silent! redir @a
"     silent! execute a:cmd
"     redir END
"   finally
"     let l:res = @a
"     let @a = l:a
"     return split(l:res, "\n")
"   endtry
" endfunction

" helper for control P to open file in preview window
function! PreviewFile(action, line)
    if a:action =~ '^e$'  
        let filename = fnameescape(fnamemodify(a:line, ':p'))
        call ctrlp#exit()
        exec 'pedit' . filename
        wincmd P 
    else
        " Use CtrlP's default file opening function
        call call('ctrlp#acceptfile', [a:action, a:line])
    endif
endfunction

" open to file under cursor with CtrlP
function! CtrlPCursorFile()
    let fname = expand("<cfile>")
    if empty(fname)
        echohl ErrorMsg
        echo "No file name under cursor"
        return
    endif

    let l:olddefault = 0
    if exists("g:ctrlp_default_input")
        let l:olddefault = g:ctrlp_default_input
    endif
    let g:ctrlp_default_input = fname

    let l:oldopenfunc = {}
    if exists("g:ctrlp_open_func")
        let l:oldopenfunc = g:ctrlp_open_func
    endif
    let g:ctrlp_open_func = { 'files' : 'PreviewFile' }

    " maybe use mixed mode instead: 0 -> ctrlp#mixed#id()?
    call ctrlp#init(0, { 'mode': 'r' })

    let g:ctrlp_default_input = l:olddefault
    let g:ctrlp_open_func = l:oldopenfunc
endfunction

" sling to tmux operator
let g:slimux_tmux_path = '/usr/bin/tmux'
function! SlingOper(type)
    if !exists("b:code_packet")
        let b:code_packet = { "target_pane": "", "type": "code" }
    endif
    let rv = getreg('"')
    let rt = getregtype('"')
    sil exe "'[,']yank"
    call SlimuxSendCode(@")
    call setreg('"',rv, rt)
endfunction

" returns a list of buffers
function! GetBufferList()
    redir =>buflist
    silent! ls!
    redir END
    return buflist
endfunction

" toggle either the quickfix or location windows 
" xxx needs work
function! ToggleList(bufname, pfx)
    let buflist = GetBufferList()
    for bufnum in map(filter(split(buflist, '\n'), 
            \ 'v:val =~ "'.a:bufname.'"'), 
            \ 'str2nr(matchstr(v:val, "\\d\\+"))')
        if bufwinnr(bufnum) != -1 && !(a:pfx == 'l' && len(getloclist(0)) == 0)
            exec(a:pfx.'close')
            return
        endif
    endfor
    if a:pfx == 'l' && len(getloclist(0)) == 0
        echohl ErrorMsg
        echo "Location list is empty."
        echohl None
        return
    endif
    let winnr = winnr()
    exec a:pfx.'open 8'
    " if winnr() != winnr
    "     wincmd p
    " endif
endfunction


command! Bind windo setl scrollbind cursorbind cursorline
command! Unbind windo setl noscrollbind nocursorbind nocursorline

" folding
set foldmethod=marker
" set foldlevel=0 foldcolumn=0
set foldtext=FoldText()

function! FoldText()
    let l:fs = nextnonblank(v:foldstart)
    if l:fs > v:foldend
        let l:line = getline(v:foldstart)
    else
        let l:line = substitute(getline(l:fs), '\t',
            \ repeat(' ', &tabstop), 'g')
    endif
    let l:cms = split(substitute(&commentstring, ' ', '', 'g' ), '%s')
    let l:line = substitute(l:line, ''.l:cms[0] . '\s*', '', '')
    let l:line = substitute(l:line, '{\{3}\d\?\s*', '', '')
    let l:line = substitute(l:line, '\s\+$', '', '')

    let l:foldSize = 1 + v:foldend - v:foldstart
    let l:foldSizeStr = l:foldSize . ' lines'
    let l:foldLevelStr = repeat('•', v:foldlevel)
    let l:lineCount = line('$')
    let l:foldPerc = printf('(%.1f%%)', (100.0*l:foldSize)/l:lineCount)
    let l:left = '[ ' . l:line . ' '
    let l:right = ' ' . l:foldSizeStr . ' '
        \ . l:foldLevelStr . ' ' . l:foldPerc . ' ]'
    let l:width = (&textwidth > 0 ? &textwidth : 74)
    let l:expansionString = repeat('·', 
        \ l:width - strwidth(l:left . l:right))
    return l:left . l:expansionString . l:right
endfunction

function! TerseOneFoldText()
    let l:line = getline(v:foldstart)
    " let line = substitute( line, '^[^0-9a-zA-Z]*', '', '' )
    let l:com_str = split(substitute(&commentstring, " ", "", "g" ), "%s")
    let line = substitute(l:line, "" . com_str[0] . "\s*", "", "" )
    " if it's a start/end comment
    if len(line) > 1
        let line = substitute( line, "\s*" . com_str[1], "", "" )
    endif
    let l:fmr = split( &foldmarker, "," )
    let line = substitute( line, "\s*"  . fmr[0] . '\d*\s*', '', '' )

    " number of folded lines
    let len  = v:foldend - v:foldstart
    let depth = v:foldlevel
    let depth_str = ">"
    while depth != 1
        let depth = depth - 1
        let depth_str .= ">"
    endwhile
    return  printf("%-5s", depth_str) . printf("%4d", len) . ': ' . line
endfunction

function! TxtFoldText()
  let level = repeat('-', min([v:foldlevel-1,3])) . '+'
  let title = substitute(getline(v:foldstart), '{\{3}\d\?\s*', '', '')
  let title = substitute(title, '^["#! ]\+', '', '')
  " return printf('%-2s %-s', level, title)
  return printf('[%s][%s]', level, title)
endfunction

function! s:ToggleTextWidth()
    if &l:textwidth > 0
        let s:old_tw = &l:textwidth
        let &l:textwidth = 0
    else
        if exists('s:old_tw')
            let &l:textwidth = s:old_tw 
        else
            let &l:textwidth = 75
        endif
    endif
endfunction

let s:default_tw = &g:textwidth ? &g:textwidth : 74
function! s:ExpandTextWidth()
    let l:tl = winsaveview().topline
    let l:longest = max(map(getline(l:tl, l:tl+winheight(0)-1), 
        \ 'strdisplaywidth(v:val)'))
    let &l:textwidth = (&l:textwidth == l:longest)
        \ ? s:default_tw
        \ : max([ s:default_tw, l:longest ])
endfunction

" XXX re-enable
" autocmd OptionSet shiftwidth noautocmd 
"       \ let &l:tabstop = &l:shiftwidth | let &l:shiftwidth=0
"

" autocmd BufReadPost * echom string(&shiftwidth).'|'.string(&l:shiftwidth)

" function! Retab(ts)
"     retab!
"     setl noexpandtab
"     let &l:shiftwidth = a:ts 
"     let &l:tabstop = a:ts
"     setl expandtab
" endfunction



" 
function! RefreshAppearance()
   if g:within_tmux
      exe 'let $'.system('tmux show-environment COLORSCHEME')
   endif
endfunction

" really clear all the registers, writes viminfo
function! s:ClearRegisters(...)
    let l:regs = a:0 ? a:1
        \ : 'abcdefghijklmnopqrstuvwxyz0123456789*+-'
    for l:r in split(l:regs, '\zs')
        if getreg(l:r) isnot ''
            call setreg(l:r, '')
        endif
    endfor
    wviminfo
    for l:r in split(l:regs, '\zs')
        call setreg(l:r, [])
    endfor
endfunction
command! -nargs=? ClearRegisters call s:ClearRegisters(<f-args>)

" requires mtth/vim-scratch XXX WIP
function! ScratchRegister()
    call scratch#open(1)
    exe '0put!'
    " exe '$delete _'
    augroup ScratchRegisterLeave
        autocmd!
        exe 'autocmd WinLeave <buffer='. bufnr('%') . '> %yank'
    augroup END
endfunction

" cause an annoying visual beep
function! Beep()
    let l:vb = &vb
    let l:eb = &eb
    set vb eb
    call feedkeys("\<esc>", 'x')
    let &vb = l:vb
    let &eb = l:eb
endfunction

" like :!, but operate on visual selection instead of lines
function! Vexecute(bang, args) range
    if empty(a:args) | return | endif
    let l:bang = a:bang ? 1 : 0 
    let l:args = a:args

    " ignore the first bang
    if !l:bang && l:args =~ '^\s*!'
        let l:args = substitute(l:args, '!', '', '')
        let l:bang = 1
    endif

    " use register z temporarily
    let l:old_z = @z
    normal! gv"zy
    let l:out = system(l:args, @z)
    let l:out = substitute(l:out, '\n$', '', '')
    call setreg('z', l:out, visualmode())
    normal! gv"zp
    let @z = l:old_z
endfunction
command! -bang -range=0 -nargs=* -complete=shellcmd V call Vexecute(<bang>0, <q-args>)

" in visual block mode, filter defaults to Vexecute 
xnoremap <expr> ! mode() == "\<c-v>" ? ':V!' : '!'

" tex increment option ('' = \relax)
let g:tex_big_list = [ '', '\big', '\Big', '\bigg', '\Bigg' ]
function! TexOptionIncrement(dir)
    let l:cur = vimtex#cmd#get_current()
    if empty(l:cur) | return 0 | endif

    " handles the case where cursor is on [\big]
    if index(g:tex_big_list, l:cur.text) >= 0
        let l:cur = vimtex#cmd#get_at([l:cur.pos_end.lnum, 
            \ l:cur.pos_end.cnum+1])
        if empty(l:cur) | return 0 | endif
    endif

    let l:direction = a:dir < 0 ? -v:count1 : v:count1

    " if already has [something]
    if !empty(l:cur.opt)
        let l:opttext = substitute(l:cur.opt.text, '\s\+$', '', '')
        let l:idx = index(g:tex_big_list, l:opttext)
        if l:idx < 0 | return 0 | endif

        let l:idx2 = (l:idx+l:direction) % len(g:tex_big_list)
        let l:new = g:tex_big_list[l:idx2]

        let l:start = l:cur.opt.open.cnum
        let l:end = l:cur.opt.close.cnum-1

        if !strlen(l:new)
            let l:start -= 1
            let l:end += 1
        endif
    else
        let l:idx2 = (0+l:direction) % len(g:tex_big_list)
        let l:new = l:idx2 > 0 ? '['.g:tex_big_list[l:idx2].']' : ''
        let l:start = len(l:cur.args) ? l:cur.args[0].open.cnum-1
            \ : l:cur.pos_end.cnum
        let l:end = l:start
    endif

    let l:pos = getcurpos()
    let l:line = getline('.')
    let l:before_text = strpart(l:line,0,l:start)
    let l:after_text = strpart(l:line,l:end)
    silent call setline('.',l:before_text.l:new.l:after_text)
    call setpos("'[",[0,line('.'),strlen(l:before_text)+1,0])
    call setpos("']",[0,line('.'),l:start+strlen(l:new),0])

    if l:pos[2] > l:start
        let l:newcol = l:pos[2] + strlen(l:new) - (l:end - l:start)
        let l:pos[2] = max([l:start, l:newcol])
        let l:pos[4] = l:pos[2]
        call setpos('.', l:pos)
    endif

    silent! call repeat#set("\<plug>".'(tex-opt-'
        \ .(a:dir < 0 ? 'decr' : 'incr').')', v:count)

    return 1
endfunction


" function to explain the different highlights for spelling errors
function! s:SpellLegend()
    for [l:group, l:explanation] in [
    \   ['SpellBad', 'word not recognized'],
    \   ['SpellCap', 'word not capitalized'],
    \   ['SpellRare', 'rare word'],
    \   ['SpellLocal', 'wrong spelling for selected region']
    \]
        echo ''
        echon l:group . "\t"
        execute 'echohl' l:group
        echon 'xxx'
        echohl None
        echon "\t" . l:explanation
    endfor
endfunction
command! -bar SpellLegend call s:SpellLegend()


" }}}1

" ────────────────────────────────────────────────────────────────────────
"      _____ __        __
"     / __(_) /__     / /___  ______  ___  _____
"    / /_/ / / _ \   / __/ / / / __ \/ _ \/ ___/
"   / __/ / /  __/  / /_/ /_/ / /_/ /  __(__  )
"  /_/ /_/_/\___/   \__/\__, / .___/\___/____/
"                      /____/_/
" ────────────────────────────────────────────────────────────────────────
" file types {{{1

" this is called before ftplugin stuff so custom maps
" can be defined on a per file type basis before plugins
function! s:PreFTPlugin(ft)
    let l:pft = 'PreFileType_'
    let l:au = l:pft.a:ft
    if exists('#User#'.l:au)
        exe 'doautocmd <nomodeline> User '.l:au
    endif

    " xxx
    call s:set_ycm_triggers(a:ft)

    " generic handler xxx this is overly complex,
    " just call the functions directly?
    " echo 'be'.a:ft | sleep 1
    let l:au = l:pft.'ALL'
    if exists('#User#'.l:au)
        exe 'doautocmd <nomodeline> User '.l:au
    endif
endfunction

" help
function! s:rc_filetype_help_maps()
    nnoremap <silent><buffer> q :<c-u>bd<cr>
    nnoremap <silent><buffer> K
        \ :<c-u>exe 'topleft help '.scriptease#helptopic()<cr>
endfunction
augroup rc_filetype_help
    au!
    autocmd FileType help if &buftype == 'help'
        \ | call s:rc_filetype_help_maps() | endif
augroup END

" latex
function! s:rc_pre_filetype_tex_maps()
    " vimtex end-wise style end completion
    imap <silent><buffer> <c-x><cr> <plug>(vimtex-delim-close)

    " shift-return alternative: xxx experimental
    execute "set <f26>=\<esc>OM"
    imap <silent><buffer> <f26> <plug>(vimtex-delim-close)

    " change directory to tex root
    nnoremap <silent><buffer> <leader>l.
        \ :<c-u>lcd <c-r>=b:vimtex.root<cr><cr>:pwd<cr>
    nnoremap <silent><buffer> <leader>lg.
        \ :<c-u>cd <c-r>=b:vimtex.root<cr><cr>:pwd<cr>

    " delimiter modifier toggling e.g., \big( -> \Big(
    nmap <silent><buffer> cd <plug>(vimtex-delim-toggle-modifier)
    nmap <silent><buffer> cD <plug>(vimtex-delim-toggle-modifier-reverse)
    xmap <silent><buffer> <c-bslash>d <plug>(vimtex-delim-toggle-modifier)
    xmap <silent><buffer> <c-bslash>D <plug>(vimtex-delim-toggle-modifier-reverse)
    nmap <silent><buffer> csE <plug>(vimtex-env-toggle-star)
    nmap <silent><buffer> csC <plug>(vimtex-cmd-toggle-star)
    " xxx find alternative maps.. cd, cD, co, cO, csd+/-?

    " analogous to cd/cD but for \norm[\big]{}
    nmap <silent><buffer> co <plug>(tex-opt-incr)
    nmap <silent><buffer> cO <plug>(tex-opt-decr)
endfunction
function! s:rc_post_filetype_tex_maps()
    " without this, ``a becomes `\alpha
    " can always use <c-v>` to insert literal `
    if g:vimtex_imaps_leader == '`'
        inoremap <silent><buffer> `` ``
    endif

    " update and compile
    nnoremap <silent><buffer> <leader><bslash> :<c-u>up<cr>:VimtexCompile<cr>
    nnoremap <silent><buffer> <F5> :<c-u>up<cr>:VimtexCompile<cr>
endfunction

augroup rc_filetype_tex
    au!
    autocmd FileType tex call textobj#user#plugin('latex', {
        \  'quote': {
        \     'pattern': ['`', "'"],
        \     'select-a': "a'", 'select-i': "i'",
        \   },
        \  'double-quote': {
        \     'pattern': ['``', "''"],
        \     'select-a': 'a"', 'select-i': 'i"',
        \   },
        \ })
    autocmd FileType tex setlocal iskeyword-=\
    " autocmd FileType tex setlocal iskeyword+=:

    autocmd User PreFileType_tex call s:rc_pre_filetype_tex_maps()
    autocmd FileType tex call s:rc_post_filetype_tex_maps()

    " zotero + betterbibtex (todo)
    " autocmd FileType tex nnoremap <buffer> <silent> <leader>c :r!cite<cr>
    " autocmd Filetype tex nmap <buffer> <silent> K <plug>(vimtex-doc-package)

    " vimtex + surround
    autocmd FileType tex call s:latexSurround()

augroup END

" matlab
augroup rc_filetype_matlab
    au!
    autocmd FileType matlab setlocal path+=~/mlpackages
        \ path+=/opt/MATLAB/R2017a/toolbox/matlab/**
        \ commentstring=%\ %s
augroup END

" quickfix
function! QuickFixFold()
    return matchstr(getline(v:lnum),'^[^|]\+') ==#
        \ matchstr(getline(v:lnum+1),'^[^|]\+') ? 1 : '<1'
endfunction
augroup rc_filetype_qf
    au!
    autocmd FileType qf setlocal wrap textwidth=0 nospell
        \ foldlevel=0 foldmethod=expr foldcolumn=1 foldopen+=jump
        \ foldexpr=QuickFixFold()
    autocmd FileType qf nnoremap <silent><buffer> q :<c-u>bd<cr>
    " autocmd FileType qf nnoremap <cr> :exe 'wincmd p \| '.line('.').'cc'<cr>
    " syn match Error /\f\+\// conceal cchar=…
augroup END

" vim
augroup rc_filetype_vim
    au!
    autocmd FileType vim nnoremap <silent><buffer> K
        \ :<C-U>exe 'topleft help '.scriptease#helptopic()<CR>
augroup END


" }}}1

" ────────────────────────────────────────────────────────────────────────
"                     __
"    _______  _______/ /_____  ____ ___     ____ ___  ____ _____  _____
"   / ___/ / / / ___/ __/ __ \/ __ `__ \   / __ `__ \/ __ `/ __ \/ ___/
"  / /__/ /_/ (__  ) /_/ /_/ / / / / / /  / / / / / / /_/ / /_/ (__  )
"  \___/\__,_/____/\__/\____/_/ /_/ /_/  /_/ /_/ /_/\__,_/ .___/____/
"                                                       /_/
" ────────────────────────────────────────────────────────────────────────
" custom maps {{{1

" clear search highlight
nnoremap <silent> <leader>/  :<C-U>nohls<CR>

" toggle airline
nnoremap <silent> <leader>_  :AirlineToggle<CR>

" latex-to-unicode via the julia plugin
nnoremap <expr> <leader>u LaTeXtoUnicode#Toggle()

" default update and compile button (using vim-dispatch)
nnoremap <silent> <leader><leader>  :<C-U>up<CR>:Make!<CR>
nnoremap <silent> <F5>              :<C-U>up<CR>:Make!<CR>

" if current file is executable and has a hashbang, allow it to run
augroup shebang_run
    autocmd!
    autocmd FileType sh     call SetShebangRun()
    autocmd FileType python call SetShebangRun()
    autocmd FileType perl   call SetShebangRun()
augroup END

" paste mode <silent> xxx
nmap  yp <Plug>unimpairedPastea
nmap  yP <Plug>unimpairedPastei

" enable/disable folding
" nnoremap [of :setlocal foldenable<cr>
" nnoremap ]of :setlocal nofoldenable<cr>

" latex stuff
" nnoremap <silent> <leader>lx :<C-U>call SetXeTex()<CR>
" nnoremap <silent> <leader>lz :<C-U>call CompileXeTex()<CR>
" noremap <silent> <leader>le :<C-U>call OpenLog()<CR>

" change to file's directory, locally or globally
nnoremap <silent> <leader>.  :<C-U>lcd %:p:h<CR>:pwd<CR>
nnoremap <silent> g.         :<C-U>cd %:p:h<CR>:pwd<CR>

" tagbar show and hide
nnoremap <silent> <leader>T  :<C-U>TagbarToggle<CR>

" figlet
nnoremap <silent> gy :set operatorfunc=FIGlet#FIGOper<cr>g@
nnoremap <silent> gyy :<c-u>exe 'normal 0gy' . v:count1 . '$'<cr>
nnoremap <silent> gY :FIGlet<cr>
vnoremap <silent> gy :FIGlet<cr>

" XXX better n/vmap for fig picker mode?
" nnoremap <silent> gY :call <sid>FigPickerMode()<cr>

" show syntax under cursor
nnoremap gb :call SyntaxAttr()<cr>
function! s:hi_show()
    let [l:l, l:c] = [line('.'), col('.')]
    echo 'hi<' . synIDattr(synID(l:l,l:c,1),'name')
        \ . '> trans<' . synIDattr(synID(l:l,l:c,0),'name')
        \ . '> lo<' . synIDattr(synIDtrans(synID(l:l,l:c,1)),'name') . '>'
endfunction
nnoremap gB :call <sid>hi_show()<cr>

" nmap <silent> g<c-b> :<c-u>HLTX!<cr>
" " this one doesn't seem to work
" nmap <sid>(hlt) <plug>HiLinkTrace

" free keys xxx
" gb show syntax
" gc tpope/commentary
" gl
" gy figlet
" gz
" zp  << map to window stuff?
" zu
" zy






    " shortcuts to evaluate vimscript
    autocmd FileType vim nnoremap <silent> <buffer> <leader><bslash>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>
    autocmd FileType vim nnoremap <silent> <buffer> <F5>
        \ :up<CR>:source %<CR>:echo 'Sourced '.expand('%')<CR>

    autocmd FileType vim vnoremap <silent> <buffer> <leader><bslash>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>
    autocmd FileType vim vnoremap <silent> <buffer> <F5>
        \ :<C-U>@*<CR>:echo (1+line("'>")-line("'<")).' lines sourced'<CR>



" TODO: use makeprg for these?
" xxx
" autocmd FileType tex noremap <silent> <leader>\  :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>
" autocmd FileType tex noremap <silent> <F5>       :<C-U>up<CR>:silent call Tex_RunLaTeX()<CR>





















" xxx would have to add this compiler back in since removed in vimtex
" autocmd FileType tex compiler latexmk | setl makeprg=latexmk





" function! PickerMode(fname)
"   set cursorline
"   let b:picker_fname = fnamemodify(a:fname, ':p')
"   nmap <buffer> <cr> :call writefile([getline(".")], b:picker_fname)<cr>:qa!<cr>
" endfunction
" command! -nargs=1 PickerMode :call PickerMode(<q-args>)



" \] slings content to tmux pane
nnoremap <silent> <leader>]   :set opfunc=SlingOper<cr>g@
nnoremap <silent> <leader>]]  :silent SlimuxREPLSendLine<cr>
vnoremap <silent> <leader>]   :SlimuxREPLSendSelection<cr>

" xxx move, make <buffer>
autocmd FileType matlab nnoremap <silent> 
    \ <leader>\ :<c-u>w<cr>:execute ":SlimuxShellRun " . expand('%:r')<cr>

" yanks to tmux.  can we make this more vimmy?
nnoremap <silent> <leader>y  :.w !tmux loadb -<CR>
vnoremap <silent> <leader>y  :w<home>silent <end> !tmux loadb -<CR>

" toggle syntastic
nnoremap <silent> <leader>s  :<C-U>SyntasticCheck<CR>
nnoremap <silent> <leader>S  :<C-U>call SyntaxToggle()<CR>

" refresh syntax highlighting
nnoremap <silent> <leader>z :<c-u>syntax sync fromstart<cr>


" set pastetoggle=
" set pastetoggle=<leader>`

" unnecessary keys
inoremap  <Up>     <NOP>
inoremap  <Down>   <NOP>
inoremap  <Left>   <NOP>
inoremap  <Right>  <NOP>
noremap   <Up>     <NOP>
noremap   <Down>   <NOP>
noremap   <Left>   <NOP>
noremap   <Right>  <NOP>

" easier movement in command mode
cnoremap <c-h> <left>
cnoremap <c-l> <right>
cnoremap <c-x> <s-left>
cnoremap <c-o> <s-right>

" prefix command history
" cnoremap <c-n> <down>
" cnoremap <c-p> <up>

" helpful expansion?
" cnoremap %<tab> <c-r>=expand('%')<cr>
" cabbrev <expr> %% expand('%:h').'/'

" XXX considered harmful?
set <a-b>=b
cnoremap <a-b> <s-left>

set <a-f>=f
cnoremap <a-f> <s-right>

" vdebug
nnoremap <Leader>x :<C-U>VdebugEval 

" quickfix and location lists
nmap <silent> <leader>W :<C-U>call ToggleList("Location List", 'l')<CR>
nmap <silent> <leader>Q :<C-U>call ToggleList("Quickfix List", 'c')<CR>

nmap <silent> <leader>w :<C-U>CtrlPLocList<CR>
nmap <silent> <leader>q :<C-U>CtrlPQuickfix<CR>

" general ctrl-p mappings
nmap <silent> <leader>t :<C-U>CtrlPTag<CR>

" xxx these are the same..
nmap <silent> <leader>6 :<C-U>CtrlPBuffer<CR>
nmap <silent> <leader>p :<C-U>CtrlPBuffer<CR>

nnoremap <silent> <leader>[ :<C-U>CtrlPMRUFiles<CR>
nnoremap <silent> <leader>o :<C-U>CtrlP<CR>
nnoremap <leader>O :<C-U>CtrlP 


    " exec 'pedit ' . a:file
    " if a:action =~ '^[tx]$' && fnamemodify(a:line, ':e') =~? '^html\?$'

    "   " Get the filename
    "   let filename = fnameescape(fnamemodify(a:line, ':p'))

    "   " Close CtrlP
    "   call ctrlp#exit()

    "   " Open the file
    "   silent! execute '!xdg-open' filename

    " elseif a:action == 'x' && fnamemodify(a:line, ':e') !~? '^html\?$'

    "   " Not a HTML file, simulate pressing <c-o> again and wait for new input
    "   call feedkeys("\<c-o>")

    " else

    "   " Use CtrlP's default file opening function
    "   call call('ctrlp#acceptfile', [a:action, a:line])

    " endif

nmap <silent> <leader>f :<C-U>call CtrlPCursorFile()<CR>

" open preview window of file under cursor (doesn't always work)
" nmap <silent> <leader>o :<C-U>exec 'pedit ' . expand('<cfile>') <CR><C-W>P
" was <tab> but this conflictrs
"

"" autocmd FileType matlab nnoremap <buffer> <leader>\ :make<CR><CR>
"" autocmd FileType matlab set makeprg=mluxrun\ %:r

" autocmd FileType matlab nnoremap <buffer> K :Mhelp <C-R>=expand('<cword>')<CR><CR>



" normal available: Ctrl-@ Ctrl-X Ctrl-K Ctrl-\ Ctrl-_ 

" increment/decrement
set nrformats+=alpha

" bootleq/vim-cycle
let g:cycle_no_mappings = 1
nmap <leader><c-a> <Plug>CycleNext
nmap <leader><c-x> <Plug>CyclePrev
let g:cycle_default_groups_for_tex = [
    \   [[ '[\big]', '[\Big]', '[\bigg]', '[\Bigg]' ], 
        \ 'match_case', 'hard_case'],
    \ ]

" AndrewRadev/switch.vim
let g:switch_mapping = ''
let g:switch_custom_definitions = [
    \   { '\(\w\)\(\[[bB]ig\{1,2}\]\)\({\)': '\1\3' },
    \ ]



    " \   [['\big\l:\big\r', '\Big\l:\Big\r', '\bigg\l:\bigg\r', 
    "     \ '\Bigg\l:\Bigg\r'], 'sub_pairs', 'hard_case', 'match_case'],
    " \ ]

" function! KonsoleSetBg(hex)
"     call system("/home/andy/script/bgchange.sh 292D3E")
" endfunction

" these can be repeated with '.' so don't really need to be easy to hit
nnoremap <leader>, <c-x>
vnoremap <leader>, <c-x>
vnoremap g<leader>, g<c-x>
nnoremap <leader>; <c-a>
vnoremap <leader>; <c-a>
vnoremap g<leader>; g<c-a>

nnoremap <silent> <plug>(tex-opt-incr) :<c-u>call TexOptionIncrement(1)<cr>
nnoremap <silent> <plug>(tex-opt-decr) :<c-u>call TexOptionIncrement(-1)<cr>

" nnoremap <c-k> <c-a>
" nnoremap <c-j> <c-x>
" vnoremap <c-k> <c-a>
" vnoremap <c-j> <c-x>
" vnoremap g<c-k> g<c-a>
" vnoremap g<c-j> g<c-x>


" function s:SID()
"     return matchstr(expand('<sfile>'), '<SNR>\zs\d\+\ze_SID$')
" endfun

" function! WordIncrement(direction)
"     let l:pat = '\V'.escape(join(
"         \ map(g:tex_big_list, 'v.val."d"'), '\|'), '\')

"     let l:line = getline('.')
"     let l:start = 0
"     while l:start >= 0 
"         let l:match = matchstrpos(l:line, l:pat, l:start)
"         let l:curp = col('.') + (mode() == 'i' ? -1 : 0)
"         if l:curp > l:match[1] && l:curp <= l:match[2]
"             let idx = index(match[0], "the")
"         endif

"         let l:start = l:match[2]
"    endwhile

"    let l:before_text = strpart(l:line,0,l:start)
"    let l:after_text = strpart(l:line,l:end)
"    silent call setline('.',l:before_text.l:new.l:after_text)
"    call setpos("'[",[0,line('.'),strlen(l:before_text)+1,0])
"    call setpos("']",[0,line('.'),l:start+strlen(l:new),0])
" endfunction


" shortcut to repeat macro (this is also control-space)
nnoremap <c-@> @@


" ctrl a conflicts with tmux
nnoremap <c-a> <nop>

" go to end of current word and start completion
function! s:EndOfWord()
    call search('\w\>','cW')
endfunction
nmap <silent> <c-x> :call <sid>EndOfWord()<cr>a<f19>

" g:ycm_key_invoke_completion
imap <c-l> <f19>

" or use chrisbra/unicode.vim
" convert :emoji: under or next to the cursor to the appropriate emoji
" works in normal mode or insert mode
" TODO: support visual mode
function! EmojiReplace()
   let l:pat = ':\([^:]\+\):'
   let l:line = getline('.')
   let l:start = 0
   while l:start >= 0 
      let l:match = matchstrpos(l:line, l:pat, l:start)
      let l:curp = col('.') + (mode() == 'i' ? -1 : 0)
      if l:curp > l:match[1] && l:curp <= l:match[2]
         let l:em = substitute(l:match[0], 
            \ l:pat, '\=emoji#for(submatch(1))', '')
         if !len(l:em)
            return 0
         endif

         call cursor(0, 1+l:match[1])
         if mode() == 'i'
            let l:line = strpart(l:line, 0, l:match[1])
                     \ . l:line[l:match[2]:]
            call setline('.', l:line)
            call feedkeys(l:em)
         else
            let l:line = strpart(l:line, 0, l:match[1])
                     \ .l:em . l:line[l:match[2]:]
            call setline('.', l:line)
         endif

         " exe 'normal! '.(l:match[1]+1).'|'
         " exe 'normal! v'.l:match[2].'|c'.l:em
         return ''
      endif
      let l:start = l:match[2]
   endwhile
   return 0
endfunction

" TODO allow repeat
nnoremap <silent> gl :call EmojiReplace()<cr>

" au CompleteDone * if len(v:completed_item) > 1 | call EmojiReplace() | endif


inoremap <c-f> <c-r>=EmojiReplace()<cr>
" inoremap <c-f> <left><c-\><c-o>:call EmojiReplace()<cr><right>


"nnoremap <silent> gl :s/:\([^:]\+\):/\=emoji#for(submatch(1), submatch(0))/g<cr>
" nnoremap <silent> gl :s/:\([^:]\+\):/\=
"     \ emoji#for(submatch(1), submatch(0))/e<cr>:nohls<cr>
" vnoremap <silent> gl :s/:\([^:]\+\):/\=
"     \emoji#for(submatch(1), submatch(0))/ge<cr>:nohls<cr>

" ycm goto
nnoremap <leader>d :YcmCompleter GoTo<CR>

" search for cursor word without jumping 
" XXX make this work in visual and backwards
" (v:searchforward = 0)
function! SearchWord()
    let @/ = '\<'.escape(expand('<cword>'), 
        \ &magic ? "/.*~[^$\\" : "/^$\\").'\>'
endfunction

" shellescape(foo, 1)
" additional = /
" return substitute(escape(a:text, '\' . ingo#regexp#GetSpecialCharacters() . a:additionalEscapeCharacters), "\n", '\\n', 'g')
" specialchars return ['^$', '^$.*[~'][&magic]
" let l:pattern = (a:0 ? a:1 : a:text)
" if a:text =~# '^\k'
" let l:pattern = '\<' . l:pattern
" endif
" if a:text =~# '\k$'
" let l:pattern .= '\>'
" endif
" return l:pattern
" endfunction

nnoremap <silent> <leader>* :call SearchWord() \| set hlsearch \| let v:searchforward = 0<cr>
nnoremap <silent> <leader># :call SearchWord() \| set hlsearch \| let v:searchforward = 1<cr>

" change cursor word and load search to quickly change occurrences
" dot can be used to repeat the search+change combo
nnoremap <leader>c :call SearchWord() \| set hlsearch<cr>cgn

" search for last small delete text
" nnoremap z/ /<c-r>-<cr>

" xxx experimental
" nnoremap <silent> <space>+
"     \ <c-w>+:call repeat#set("<c-v><c-w>+", v:count)<cr>
" nnoremap <silent> <space>-
"     \ <c-w>-:call repeat#set("<c-v><c-w>-", v:count)<cr>
" nnoremap <silent> <space><lt>
"     \ <c-w><lt>:call repeat#set("<c-v><c-w><lt>", v:count)<cr>
" nnoremap <silent> <space>>
"     \ <c-w>>:call repeat#set("<c-v><c-w>>", v:count)<cr>

" reload vimrc
nnoremap <silent> <leader>` :ReloadVimrc<cr>
nnoremap <silent> <leader>~ :PlugUpdate<cr>


" XXX experimental (does this break copy paste in tmux??)
" see: sjl/vitality.vim, tmux-plugins/vim-tmux-focus-events,
" amerlyq/vim-focus-autocmd wincent/terminus
function! SetupFocusReporting()
    let save_screen = "\<Esc>[?1049h"
    let restore_screen = "\<Esc>[?1049l"
    let tmux_start = "\<Esc>Ptmux;"
    let tmux_end = "\<Esc>\\"
    let enable_focus_reporting = "\<Esc>[?1004h"
    let escaped_enable_focus_reporting = tmux_start
                \ . "\<Esc>" . enable_focus_reporting
                \ . tmux_end
                \ . enable_focus_reporting
    let disable_focus_reporting = "\<Esc>[?1004l"

    let &t_ti = escaped_enable_focus_reporting . save_screen
    let &t_te = disable_focus_reporting . restore_screen
    exec "set <F24>=\<Esc>[O"
    exec "set <F25>=\<Esc>[I"

    nnoremap <silent> <f24> :silent doautocmd FocusLost %<cr>
    nnoremap <silent> <f25> :silent doautocmd FocusGained %<cr>

    onoremap <silent> <f24> <esc>:silent doautocmd FocusLost %<cr>
    onoremap <silent> <f25> <esc>:silent doautocmd FocusGained %<cr>

    vnoremap <silent> <f24> <esc>:silent doautocmd FocusLost %<cr>gv
    vnoremap <silent> <f25> <esc>:silent doautocmd FocusGained %<cr>gv

    inoremap <silent> <f24> <c-\><c-o>:silent doautocmd FocusLost %<cr>
    inoremap <silent> <f25> <c-\><c-o>:silent doautocmd FocusGained %<cr>

    cnoremap <silent> <f24> <c-\>e<SID>DoCmdModeFocus('FocusLost')<cr>
    cnoremap <silent> <f25> <c-\>e<SID>DoCmdModeFocus('FocusGained')<cr>
endfunction

function! s:DoCmdModeFocus(event)
    let cmd = getcmdline()
    let pos = getcmdpos()
    exec 'silent doautocmd '.a:event.' %'
    call setcmdpos(pos)
    return cmd
endfunction

if g:within_tmux
    call SetupFocusReporting()
endif


" XXX smart-ish re-layout
" this has the nice properties of mostly preserving order,
" but does not swap out to master correctly
function! Relayout()
   " in order, bring each window to bottom
   let l:nr = winnr()
   let l:nrlast = winnr('#')
   windo wincmd J
   exe l:nrlast.'wincmd w'
   exe l:nr.'wincmd w'

   " if there are enough columns, bring master to left
   " otherwise, bring master to bottom and maximize
   if &columns > (&textwidth)+50
      wincmd H
      exe (2+&numberwidth+&textwidth).'wincmd|'
   else
      wincmd K
      wincmd _
   endif
endfunction
nnoremap <silent> <c-w><space> :call Relayout()<cr>


" command! -nargs=* LayoutH call window#layout('ball', 'H', <args>)
" nnoremap <c-w><space> :<c-u>LayoutH v:count<cr>

nnoremap <C-w>gl :<C-U>call window#join('rightbelow vsplit', v:count) <BAR>normal! 100zh<CR>
nnoremap <C-w>gh :<C-U>call window#join('leftabove vsplit', v:count)  <BAR>normal! 100zh<CR>
nnoremap <C-w>gj :<C-U>call window#join('belowright split', v:count)  <BAR>normal! 100zh<CR>
nnoremap <C-w>gk :<C-U>call window#join('aboveleft split', v:count)   <BAR>normal! 100zh<CR>
nnoremap <C-w>e :<C-U>call window#exchange(v:count)<cr>

" sanity
" stack
" bi-stack
" tri-stack
" accordionize
" by name
" option: ball or only visible

" using wincmd allows us to repeat with @: (XXX but wait not actually...?)
" nmap , :5wincmd <<cr>
" nmap . :5wincmd ><cr>

function! s:res_ver_increm()
    return float2nr(round(&columns*0.03))
endfunction
function! s:res_hor_increm()
    return float2nr(round(&lines*0.08))
endfunction

" alt codes for window resizing
set <a-,>=, <a-.>=.  <a-lt>=< <a-char-62>=>
set <a-->=- <a-=>== <a-_>=_ <a-+>=+

" shifted maps
nnoremap <silent> <a-,> :vertical res -5<cr>
nnoremap <silent> <a-.> :vertical res +5<cr>
nnoremap <silent> <a--> :res -3<cr>
nnoremap <silent> <a-=> :res +3<cr>

" unshifted maps
nnoremap <silent> <a-lt> :vertical res -1<cr>
nnoremap <silent> <a-char-62> :vertical res +1<cr>
nnoremap <silent> <a-_> :res -1<cr>
nnoremap <silent> <a-+> :res +1<cr>

" nnoremap gl :exe 'echo '.v:count<cr>

set noequalalways  " window management
" set eadirection=ver,hor,both

" enough for 3 windows stacked vertically with LINES=38, winminheight=1
" set winheight=32 winwidth=16
set winheight=16 winwidth=16
set winminheight=1 winminwidth=0

let g:windowswap_map_keys = 0
" XXX better keymaps?
"     why doesn't airline work with this?
nnoremap <c-w>m :call WindowSwap#MarkWindowSwap()<CR>
nnoremap <c-w>' :call WindowSwap#DoWindowSwap()<CR>

" see airline extension for windowing

" comma join
nnoremap <silent> <leader>J :Join ', '<cr>
vnoremap <silent> <leader>J :Join ', '<cr>

" zero-paste: convert register to character-wise
function! ZeroPaste(p)
    call setreg(v:register, getreg(v:register), 'c')
    exe 'normal "'.v:register.a:p
endfunction
nnoremap <silent> zp :<c-u>call ZeroPaste('p')<cr>
nnoremap <silent> zP :<c-u>call ZeroPaste('P')<cr>

" change-paste: like visual paste but preserves " register
" usually want cpw/cpiw 
" the removed text goes into the "- register
" repeat already works
function! ChangePasteOp(motionType)
    let l:save = @"
    let l:reg = s:change_paste_register
    if l:reg == '='
        let @" = getreg(s:change_paste_register)
        let l:reg = '"'
    endif
    if s:EmptyRegion()
        normal! `]
    elseif a:motionType == 'line'
        normal! '[V']
    elseif a:motionType == 'char'
        normal! `[v`]
    endif
    exe 'normal! "'.l:reg.'p'
    let @" = l:save
    if maparg('w', 'o') == maparg('<sid>(cp-w-oper)', 'o')
        ounmap w
    endif
endfunction

function! s:EmptyRegion()
    let l:begin = getpos("'[")
    let l:end = getpos("']")
    return l:begin[1] == l:end[1] && l:end[2] < l:begin[2]
endfunction

" self-destructing omap
onoremap <expr> <sid>(cp-w-oper) <sid>ChangePasteW()
function! s:ChangePasteW()
    if &operatorfunc == 'ChangePasteOp' && v:operator == 'g@'
        return 'e'
    endif
    if maparg('w', 'o') == maparg('<sid>(cp-w-oper)', 'o')
        ounmap w
    endif
    return 'w'
endfunction

" set up change-paste
function! s:ChangePaste()
    set operatorfunc=ChangePasteOp
    let s:change_paste_register = v:register
    if maparg('w', 'o') == ""
        exe 'onoremap <expr> w '.maparg('<sid>(cp-w-oper)', 'o')
    endif
    return 'g@'
endfunction
nnoremap <expr> <sid>(cp-start) <sid>ChangePaste()
nmap <silent> cp <sid>(cp-start)

nmap <silent> cpp cp_
nmap <silent> cP cp$

" special case similar to cw
nmap <silent> cpw cpe

" vinegar
" nmap <leader>- <Plug>VinegarSplitUp
" nmap g= <Plug>VinegarVerticalSplitUp
nmap <leader>- <Plug>VinegarUp

" do not let vinegar override this map 
" nnoremap - -

" iabbr <expr> ]] vimtex#delim#close()
" imap <f26> <plug>(vimtex-delim-close)

" todo
" ViewDocWrapper preserve registers
" ViewDoc for other file types

" a somewhat more useful go-to-middle of screen
nnoremap <silent> gM gm
nnoremap <silent> gm :exe 'normal '.float2nr(1+&tw/2).'\|'<cr>

" clipbrd
nnoremap <leader>r :exe 'ClipBrd '.v:register<cr>z6<cr>

" training
function! s:Train(c)
    echo 'Did you really mean to type '.a:c.'?'
    call Beep() | return a:c
endfunction
nnoremap <silent><expr> q <sid>Train('q')

" toggle textwidth/column
nnoremap <silent> <leader>v :<c-u>call <sid>ToggleTextWidth()<cr>

" set textwidth to longest line current screen, or default
nnoremap <silent> <leader>V :<c-u>call <sid>ExpandTextWidth()<cr>

" get the script where option was last set
function! OptionWhereSet(optname)
    let l:savemore = &more
    noa set nomore
    redir => l:lines
    sil execute 'verbose set '.a:optname.'?'
    redir END
    noa let &more = l:savemore

    let l:source = matchlist(l:lines, 'Last set from \(.\+\)$')
    if len(l:source) == 0
        return ''
    end
    return l:source[1]
endfunction

" record option settings
function! s:OptRecord()
    let l:optname = expand("<amatch>")
    let l:rec = [ v:option_old, v:option_new, v:option_type, l:optname ]

    let l:source = OptionWhereSet(l:optname)
    if empty(l:source) | let l:source = '???' | endif
    call add(l:rec, l:source)

    call add(g:opt_hist, l:rec)
endfunction

function! s:OptRecordStart()
    let g:opt_hist = []
    augroup rc_OptionSet
        au!
        au OptionSet * call s:OptRecord()
    augroup END
endfunction
function! s:OptRecordStop()
    augroup rc_OptionSet
        au!
    augroup END
    let l:opt_hist = g:opt_hist
    let g:opt_hist = []
    return l:opt_hist
endfunction

command! RecordOptions call s:OptRecordStart()

" temporarily force modeline read regardless of 'modeline' setting
function! s:DoModelines()
  augroup DoModelines_augroup
    au!
    au User DoModelines if 0 | endif
  augroup END
  let l:modeline = &modeline
  noa set modeline

  call s:OptRecordStart()
  doautocmd User DoModelines
  let l:opt_hist = s:OptRecordStop()

  noa let &modeline = l:modeline

  for l:o in l:opt_hist
    echo l:o[3] '('.l:o[2].')' l:o[0] '->' l:o[1]
  endfor
endfunction
command! Modelines call <sid>DoModelines()
nnoremap <silent> <leader>m :<c-u>call <sid>DoModelines()<cr>

" go to column stored in mark without changing the line
" if the mark is >, then selection is set to current column
" if the mark is $, expand to longest line, textwidth, or winwidth
function! s:vblock_rest()
    let l:c = nr2char(getchar())
    if index(['<', "\<cr>", "\<c-l>"], l:c) > -1
        return col('v').'|'
    endif
    if l:c == '>'
        let l:col = getcurpos()[2] + getcurpos()[3]
        return 'o'.l:col.'|o'
    endif
    if l:c == '$'
        let [l:a, l:b] = [line('v'), line('.')]
        if l:a > l:b | let [l:a, l:b] = [l:b, l:a] | endif
        let l:longest = max(map(getline(l:a, l:b),
            \ 'strdisplaywidth(v:val)'))
        let l:col = getcurpos()[2] + getcurpos()[3]
        if l:col != l:longest
            return l:longest.'|'
        elseif &textwidth > 0
            return &textwidth.'|'
        else
            return winwidth(0).'|'
        endif
    endif
    return col("'".l:c).'|'
endfunction
xnoremap <expr> <c-l> <sid>vblock_rest()

" stuff v:register into clipboard, after the fact
function! s:reg_stuff_clip()
    if $SSH_CLIENT != ''
        let l:clipfile = expand('~/.ssh_clipboard')
        call writefile(split(getreg(), '\n'), l:clipfile, 'a')
        echo '"'.v:register 'stored in file' l:clipfile
        return
    endif

    call setreg('+', getreg(), getregtype()) 
    echo '"'.v:register.' yanked into clipboard'
endfunction

" ["x]yc puts register into clipboard +
nnoremap <silent> yc :<c-u>call <sid>reg_stuff_clip()<cr>

" go down (or up) to nearest non-empty in the same column
function! s:vcol_updown(back)
    let l:col = getcurpos()[2] + getcurpos()[3]
    let l:line = search('\%'.l:col.'c\S', 'nW'.(a:back?'b':''))
    return l:line.'G'
endfunction
xnoremap <expr> <c-j> <sid>vcol_updown(0)
xnoremap <expr> <c-k> <sid>vcol_updown(1)

" }}}1

" ────────────────────────────────────────────────────────────────────────
"                               _                      __
"    ___  _  ______  ___  _____(_)___ ___  ___  ____  / /______
"   / _ \| |/_/ __ \/ _ \/ ___/ / __ `__ \/ _ \/ __ \/ __/ ___/
"  /  __/>  </ /_/ /  __/ /  / / / / / / /  __/ / / / /_(__  )
"  \___/_/|_/ .___/\___/_/  /_/_/ /_/ /_/\___/_/ /_/\__/____/
"          /_/
" ────────────────────────────────────────────────────────────────────────
" experiments {{{1

" fix bug(?) in vim/Konsole
" Konsole does not support this particular escape sequence
" if g:rc_term_konsole
" set t_SH=

if &term =~ '^konsole'
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif

" useful after doing grep
function! Bwipeunlisted()
    let l:bufs = filter(range(1, bufnr('$')), 'bufexists(v:val)')
    call filter(l:bufs, '!buflisted(v:val)')
    let l:count = 0
    for l:i in l:bufs
        let l:count += 1
        silent execute 'bwipeout' l:i
    endfor
    if l:count > 0
        echo l:count 'buffers wiped out'
    endif
endfunction
command! Bwipeunlisted call Bwipeunlisted()

"  XXX experimental
function! ColumnLock()
    if mode() != '' | return '' | endif

    function! s:ColumnLock_Enable(state)
        if !a:state | let g:column_lock = 0 | endif
        augroup ColumnLock_augroup
            au!
            if a:state
                au CursorMoved * call <sid>ColumnLock_CursorMoved()
            endif
        augroup END
    endfunction

    function! s:ColumnLock_CursorMoved()
        if mode() != ''
            call s:ColumnLock_Enable(0)
            return
        endif

        if col('.') != g:column_lock
            exe 'normal '.g:column_lock.'|'
            " call cursor(0, g:column_lock)
        endif
    endfunction

    let s:activate = !get(g:, 'column_lock', 0)
    let g:column_lock = s:activate ? col('.') : 0
    call s:ColumnLock_Enable(s:activate)

    if s:activate
        echo 'column locked'
    else
        echo 'column unlocked'
    endif

    return ''
endfunction
" nnoremap <expr> <leader>b ColumnLock()
" xnoremap <expr> <leader>b ColumnLock()
" function! s:vblock_rest()
"     return col('v').'|'
" endfunction
"
" this works:
" function! s:vblock_store()
"     let s:vblock_rest_col = col('.')
"     echo "column stored\r"
"     return ''
" endfunction
" function! s:vblock_rest()
"     let l:c = get(s:, 'vblock_rest_col', 0)
"     if l:c == 0
"         return ''
"     endif
"     return l:c.'|'
" endfunction
" xnoremap <expr> <c-k> <sid>vblock_rest()
" xnoremap <expr> <c-l> <sid>vblock_store()

" TagHighlightSettings
function! UTTest()
    if ! exists('g:TagHighlightSettings')
        let g:TagHighlightSettings = {}
    endif
    let l:tf = tagfiles()
    if !empty(l:tf)
        let g:TagHighlightSettings['TagFileName'] = l:tf[0]
        exe 'UpdateTypesFileOnly'
    else
        let g:TagHighlightSettings['TagFileName'] = ''
    endif
endfunction

" xxx experimental
function! QF_reshow()
    if &buftype isnot '' | return | endif
    let l:win = filter(getwininfo(),
        \ 'v:val.quickfix && !v:val.loclist')
    if !empty(l:win)
        exe l:win[0].winnr.'windo normal! zMzv'
    endif
endfunction
augroup qf_something
    au!
    " au BufWinEnter * call QF_reshow()
augroup END

" }}}1

" final setup
call SiteSetupPost()

function! FixIndents()
    call SecureModelines_DoModelines()
    echo &et &ts &sw &sts &sta
endfunction

function! s:init()
    " make servername available to (all) child processes
    let $VIM_SERVERNAME=v:servername

    call ColorsEnter()
    call SiteEnter()

    " add a hook to securemodelines
    if get(g:, 'loaded_securemodelines', 0)
        augroup SecureModeLines
            au!
            " au BufRead,StdinReadPost * call FixIndents()
        augroup END
    endif

    " undo vim-vinegar's default map
    if get(g:, 'loaded_vinegar', 0) && maparg('-', 'n') != ''
        unmap -
    endif

    " fix for unimpaired virtualedit
    nnoremap [ov :<c-u>call <sid>virtualedit_all(1)<cr>
    nnoremap ]ov :<c-u>call <sid>virtualedit_all(0)<cr>
    nnoremap =ov :<c-u>call <sid>virtualedit_all(-1)<cr>

    " XXX testing
    if g:rc_disable_youcompleteme
        let g:latex_to_unicode_suggestions = 1
    endif
endfunction

if v:vim_did_enter
    call s:init()
else
    au VimEnter * nested call s:init()
endif

set secure

" vim: sw=4

